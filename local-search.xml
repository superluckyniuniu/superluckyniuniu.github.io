<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>滑动窗口</title>
    <link href="/2024/03/31/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2024/03/31/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>借鉴：<a href="https://www.cnblogs.com/huansky/p/13488234.html">https://www.cnblogs.com/huansky/p/13488234.html</a></p><p>​           <a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/solutions/1362316/by-dodo_1202-cqbe/">https://leetcode.cn/problems/substring-with-concatenation-of-all-words/solutions/1362316/by-dodo_1202-cqbe/</a></p><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>滑动窗口是在给定大小的数组和字符串上进行平滑操作，找到指定内容的方法。由于需要两指针，因此通常需要一些辅助方法，如哈希表（即python中的dict,用于标记元素位置），或集合（即python中的set(),创建一个无序不重复元素集），优先队列，红黑树，单调队列，大小堆等等，应根据各种数据结构的特点来选取。</p><h3 id="思考（也是考点）："><a href="#思考（也是考点）：" class="headerlink" title="思考（也是考点）："></a>思考（也是考点）：</h3><p>1、窗口使用什么数据结构<br>2、达到窗口限定后，左边届该怎样收缩，如果无法以常规方法收缩，考虑延时删除策略（在采集答案前进行）<br>3、怎样采集答案<br>4、滑窗的步长<br>5、滑窗的起始位置<br>6、是否需要数据预处理，例如排序，才能使用滑窗</p><h2 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h2><blockquote><p>1、对字符串 S（或数组） 使用双指针中的左右指针技巧，初始化left &#x3D; right &#x3D; 0。 索引闭区间[ left,right]称为一个窗口。</p><p>2、不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）</p><p>3、停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。</p><p>4、重复第2 步和第三步，直到right到达字符串S的尽头</p></blockquote><p>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。</p><p>下面画图理解一下，needs 和 window 相当于计数器，分别记录 T 中字符出现次数和窗口中的相应字符的出现次数。</p><p>初始状态：</p><img src="../picture/2019101621574345.png" alt="在这里插入图片描述" style="zoom:50%;" /><p>增加 right，直到窗口 [left, right] 包含了 T 中所有字符：</p><img src="../picture/20191016215752186.png" alt="在这里插入图片描述" style="zoom:50%;" /><p>现在开始增加 left，缩小窗口 [left, right]。</p><img src="../picture/20191016215807735.png" alt="在这里插入图片描述" style="zoom:50%;" /><p>直到窗口中的字符串不再符合要求，left 不再继续移动。</p><img src="../picture/20191016215824468.png" alt="在这里插入图片描述" style="zoom:50%;" /><p>之后重复上述过程，先移动 right，再移动 left…… 直到 right 指针到达字符串 S 的末端，算法结束。</p><h3 id="寻找最长"><a href="#寻找最长" class="headerlink" title="寻找最长"></a>寻找最长</h3><p>【如果】窗内满足条件， R 向右扩大窗口,并更新最优结果</p><p>【如果】不满足条件， L向右缩小窗口</p><h3 id="寻找最短"><a href="#寻找最短" class="headerlink" title="寻找最短"></a>寻找最短</h3><p>【如果】窗内满足条件， L 向右缩小窗口,并更新最优结果</p><p>【如果】不满足条件， R向右扩大窗口</p><p>例题：[30. 串联所有单词的子串 - 力扣（LeetCode）](<a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">https://leetcode.cn/problems/substring-with-concatenation-of-all-words/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> collection<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Sliding</span> Window(s,t): <span class="hljs-comment"># t即题目中的words</span><br>    n = <span class="hljs-built_in">len</span>(s)<br>    stride = <span class="hljs-built_in">len</span>(t[<span class="hljs-number">0</span>]) <span class="hljs-comment">#定义步长</span><br>    limit = <span class="hljs-built_in">len</span>(words) * stride<br>    <br><br>    <span class="hljs-comment">#它的其他功能与dict相同，但会为一个不存在的键提供默认值，从而避免KeyError异常。    </span><br>    needs = collections.defaultdict(<span class="hljs-built_in">int</span>)<br>    ans = []<br>    <br>    <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> t:<br>        need[w] += <span class="hljs-number">1</span> <br>    <span class="hljs-keyword">for</span> strat <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,stride):<br>        left = right = strat <span class="hljs-comment">#指向当前步子的第一个下标</span><br>        cnt = <span class="hljs-number">0</span> <span class="hljs-comment">#记录窗口内满足要求得单词数</span><br>        window = collections.defaultdict(<span class="hljs-built_in">int</span>)<br><span class="hljs-keyword">while</span> right &lt; n:<br>            <span class="hljs-comment">#右边界入窗</span><br>            cur_right = s[right:right+stride]<br>            <span class="hljs-keyword">if</span> cur_right <span class="hljs-keyword">in</span> need:<br>                window[cur_right] += <span class="hljs-number">1</span><br>               <span class="hljs-keyword">if</span> window[cur_right] == need[cur_right]:<br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 左边界收缩</span><br>            <span class="hljs-keyword">if</span> right - left + stride &gt; limit:<br>                cur_left = s[left:left+stride]<br>                <span class="hljs-keyword">if</span> cur_right <span class="hljs-keyword">in</span> need:<br>                    <span class="hljs-keyword">if</span> window[cur_left] == need[cur_left]:<br>                        cnt -= <span class="hljs-number">1</span><br>                    window[cur_left] -= <span class="hljs-number">1</span><br>                    left += stride<br>            <span class="hljs-comment">#采集答案</span><br>            <span class="hljs-keyword">if</span> right - left +stride == limit <span class="hljs-keyword">and</span> cnt == <span class="hljs-built_in">len</span>(need):<br>                ans.append(left)<br>            right += stride<br><span class="hljs-keyword">return</span> ans<br>            <br>                           <br></code></pre></td></tr></table></figure><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>本模板左右平移步长为1 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> collection<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Sliding</span> Window(s,t):<br>    left = right = <span class="hljs-number">0</span><br>    valid = <span class="hljs-number">0</span> <span class="hljs-comment"># 窗口内已凑齐的字符种类数量</span><br>    window = collections.defaultdict(<span class="hljs-built_in">int</span>)<br>    needs = collections.defaultdict(<span class="hljs-built_in">int</span>)<br>    <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> t:<br>        needs[w] += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> right &lt; <span class="hljs-built_in">len</span>(s):<br>       <span class="hljs-comment">#右边界入窗，对窗口内数据的一系列更新</span><br>        window[s[right]] += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> window[s[right]] == need [s[right]]:<br>            valid += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 注意，先判断再加</span><br>        <br>        <span class="hljs-comment">#判断左侧是否要收缩</span><br>        <span class="hljs-keyword">while</span> 需要收缩:<br>            <span class="hljs-comment">#左边界移除窗口，进行窗口内数据更新</span><br>            <span class="hljs-keyword">if</span> window[s[left]] == need[s[left]]:<br>                valid -= <span class="hljs-number">1</span><br>                <span class="hljs-comment">#先判断再减</span><br>            window[s[left]] -= <span class="hljs-number">1</span><br>            left += <span class="hljs-number">1</span> <span class="hljs-comment"># 注意左侧进行收缩</span><br>        <br>        采集答案<br>        right += <span class="hljs-number">1</span><br>        <br>        <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希表</title>
    <link href="/2024/03/25/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2024/03/25/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote><p>哈希表（又称散列表）， 是一种线性表的存储结构。哈希表由一个直接寻址表和一个哈希函数组成。哈希函数h(k)将元素关键字K作为自变量，返回元素的存储下标。</p></blockquote><h5 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h5><p>例：假设由一个长度为7 的哈希表，哈希函数h(k)&#x3D;k%7。元素集合{14，22，3，5}的存储方式如下表</p><table><thead><tr><th align="center">value</th><th align="center">14</th><th align="center">22</th><th align="center"></th><th align="center">3</th><th align="center"></th><th align="center">5</th><th align="center"></th></tr></thead><tbody><tr><td align="center">i(k%7)</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td></tr></tbody></table><h5 id="直接寻址表"><a href="#直接寻址表" class="headerlink" title="直接寻址表"></a>直接寻址表</h5><p><img src="/.././picture/2feda0dae07f167fa5fa3f320dddf59.png" alt="2feda0dae07f167fa5fa3f320dddf59"></p><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><blockquote><p>当域U很大时，需要消耗大量内存,不实用</p><p>如果域U很大，但实际出现的key很少，则大量空间被浪费</p><p>无法处理关键字不是数字的情况</p></blockquote><h6 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h6><blockquote><p>构建大小为m的寻址表T</p><p>key为k的元素放在h(k)位置上</p><p>h(k)时一个函数，其将域U映射道表T[0,1,2,……,m-1]</p></blockquote><h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><p>当哈希函数返回的位置已经有值时，就会出现哈希冲突</p><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><blockquote><p>开放寻址法 ： 如果哈希函数返回的位置已经有值，则可以向后探查新的位置来存储这个值</p><p>线性探查   ： 如果位置 i 被占用 ， 则探查 i+1, i+2 ,……..</p><p>二次探查  ： 如果位置 i 被占用 ，则探查i+1^2^ , i-1^2^, i +2^2^  ,i-2^2^</p><p>二度哈希 ： 有n个哈希函数，当使用第1个哈希函数h1法生冲突时，则尝试使用h2,h3</p><p>链表法 ： 哈希表每个位置都链接一个链表，当冲突发生时，冲突的元素将被加到该位置链表的最后。</p></blockquote><table><thead><tr><th align="center">0</th><th align="center">496</th><th align="center">896</th><th align="center"></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">337</td><td align="center">356</td></tr><tr><td align="center">2</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">3</td><td align="center">367</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">4</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">5</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">6</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">7</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">8</td><td align="center">184</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">9</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">10</td><td align="center">26</td><td align="center">126</td><td align="center"></td></tr></tbody></table><h4 id="常用哈希函数"><a href="#常用哈希函数" class="headerlink" title="常用哈希函数"></a>常用哈希函数</h4><blockquote><p>除法哈希表：</p><blockquote><p>h(k) &#x3D; k %m</p></blockquote><p>乘法哈希表：</p><blockquote><p>h(k) &#x3D; floor(m * (A * key%1))</p></blockquote><p>全域哈希表：</p><blockquote><p>Ha,b(k) &#x3D; ((a*key + b ) mod p) mod m      a,b &#x3D;1,2,…..,p-1</p></blockquote></blockquote><h4 id="哈希表代码实现"><a href="#哈希表代码实现" class="headerlink" title="哈希表代码实现"></a>哈希表代码实现</h4><p>哈希表  通过哈希函数来计算数据存储位置的数据结构，通常支持如下操作：</p><blockquote><p>insert(key,value):  插入键值(key,value)</p><p>get(key): 如果存在键为key的键值对则返回其value,否则返回空值</p><p>delete(key): 删除键为key的键值对</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs pyhon">class Linklist:<br>    class Node:<br>        def __init__(self,item=None):<br>            self.item = item<br>            self.next = None<br>    class LinklistIterator: #迭代器类  for循环依赖于迭代器,不写迭代器的话,链表不能for循环<br>        def __init__(self,node):<br>            self.node = node<br>        def __next__(self):<br>            if self.node:<br>                cur_node = self.node<br>                self.node = cur_node.next<br>                return cur_node.item<br>            else:<br>                raise StopIteration<br>        &#x27;&#x27;&#x27;<br>        代器规定必要有这个函数 目的是为了 iterator本身必须是iterable<br>        因此定义__iter__ 函数当对iterator求自身iterator时调用自己<br>    <br>       &#x27;&#x27;&#x27;<br>        def __iter__(self):  #迭<br>            return self<br>    def __init__(self,iterable = None):<br>        self.head = None<br>        self.tail = None<br>        if iterable:<br>            self.extend(iterable)<br>    def append(self,obj):<br>        s = Linklist.Node(obj)<br>        if not self.head:<br>            self.head = s<br>            self.tail = s<br>        else:<br>            self.tail.next = s<br>            self.tail = s<br>    def extend(self,iterable):<br>        for obj in iterable:<br>            self.append(obj)<br>    def find(self,obj):<br>        for n in self:<br>            if n == obj:<br>                return True<br>        else:<br>            return False<br>    def __iter__(self): <br>        return self.LinklistIterator(self.head)<br>    def __repr__(self): #转化为字符串<br>        return &quot;&lt;&lt;&quot;+&quot;,&quot;.join(map(str,self))+&#x27;&gt;&gt;&#x27;<br>    &#x27;&#x27;&#x27;map是python内置函数，会根据提供的函数对指定的序列做映射。<br>    map()函数的格式是：map(function,iterable,...) <br>    参数:<br>    function是一个函数名称，通过该函数对后续参数iterable进行处理<br>    iterable是一个可迭代对象，比如：字符串、列表、字典、元组、集合等<br>    &#x27;&#x27;&#x27;<br><br>#类似于集合的结构<br>class HashTable:<br>    def __init__(self,size=101):#size定义哈希表长度<br>        self.size = size<br>        self.T = [Linklist() for i in range(self.size)]<br>    <br>    def h(self,k):<br>        return k % self.size<br>        <br>    def insert(self,k):<br>        i = self.h(k) #k的位置 <br>        if self.find(k):<br>            print(&#x27;重复插入&#x27;)<br>        else:<br>            self.T[i].append(k)<br>    <br>    def find(self,k):<br>        i = self.h(k)<br>        return self.T[i].find(k)<br>ht = HashTable()<br>ht.insert(0)<br>ht.insert(1)<br>ht.insert(101)<br>a= ht.T[0].head.next.item<br>print(a)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kmb算法</title>
    <link href="/2024/03/25/kmb%E7%AE%97%E6%B3%95/"/>
    <url>/2024/03/25/kmb%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h3><p>kmp算法被用来做字符串的匹配。即 快速在 原字符串 中找到 匹配字符串</p><p>kmp算法的复杂度为O(m+n)</p><p>前缀： 包含首字母但不包含尾字母的所有子串。</p><p>后缀：包含尾字母但不包含首字母的所有子串。</p><p>匹配值为 前缀和后缀最大相同字串的长度</p><p>例：</p><pre><code class="hljs"> A B C C A B</code></pre><table><thead><tr><th align="center">前缀</th><th align="center">后缀</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">B</td></tr><tr><td align="center">AB</td><td align="center">AB</td></tr><tr><td align="center">ABC</td><td align="center">CAB</td></tr><tr><td align="center">ABCC</td><td align="center">CCAB</td></tr><tr><td align="center">ABCCA</td><td align="center">BCCAB</td></tr></tbody></table><p>匹配值为 2 （AB）</p><p>所以逐步获取 该字符串的匹配表为：</p><table><thead><tr><th>A</th><th>匹配值为 0</th></tr></thead><tbody><tr><td>AB</td><td>0</td></tr><tr><td>ABC</td><td>0</td></tr><tr><td>ABCC</td><td>0</td></tr><tr><td>ABCCA</td><td>1</td></tr><tr><td>ABCCAB</td><td>2</td></tr></tbody></table><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>当发现某一个字符不匹配时，利用之前遍历过的字符信息来避免暴力算法中的  “回退” 的步骤.</p><p>KMP 算法通过生成的next 数组，当匹配失败时 看最后匹配成功的字符所对应的next 数值p。</p><p>将字串patt的指针返回到 patt [p] 。(p代表字串中可以跳过的字串个数，也即对应字串中的匹配值)</p><p>例：</p><p>主串  A B A B A B C A A </p><p>子串  [A B A B C]</p><p>NEXT [0 0 1  2 0]</p><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">A</th><th align="center">B</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">A</th><th align="center">A</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">B</td><td align="center">A</td><td align="center">B</td><td align="center">C ×</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">0</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>当匹配到 子串 第一个数值时 发现不匹配。因此根据最后匹配成功的的字符 B 对应的next值 2 将指针指到 第2 个A 所在的位置继续匹配。（因为ABAB 匹配值为2  所以之前匹配成功的 AB 与 字串开头的两个 AB 完全一样，因此可以 跳过最长匹配字符 接着看之后数值是否匹配。）</p><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">A</th><th align="center">B</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">A</th><th align="center">A</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center">A</td><td align="center">B</td><td align="center">A</td><td align="center">B</td><td align="center">C</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">0</td><td align="center"></td><td align="center"></td></tr></tbody></table><p>不再需要回退主串中的指针，只需一次便利便可完成匹配 增加了效率</p><h4 id="Next-数组-和-KMP算法实现"><a href="#Next-数组-和-KMP算法实现" class="headerlink" title="Next 数组 和 KMP算法实现"></a>Next 数组 和 KMP算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_next</span>(<span class="hljs-params">patt</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    计算 Next数组</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-built_in">next</span> = [<span class="hljs-number">0</span>] <span class="hljs-comment"># next 数组(初值元素为0)</span><br>    prefix_len = <span class="hljs-number">0</span> <span class="hljs-comment"># 当前共同前后缀的长度</span><br>    i = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(patt):<br>        <span class="hljs-keyword">if</span> patt[prefix_len] == patt[i]:  <span class="hljs-comment">#如果下个字符相同 即可构成更长度的前后缀</span><br>            prefix_len += <span class="hljs-number">1</span><br>            <span class="hljs-built_in">next</span>.append(prefix_len)<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> prefix_len == <span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">next</span>.append(<span class="hljs-number">0</span>) <span class="hljs-comment">#当查表后，依然不存在相应的 数值，则将对应next设为0</span><br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                prefix_len = <span class="hljs-built_in">next</span>[prefix_len - <span class="hljs-number">1</span>] <br>                <span class="hljs-comment"># 当下一个字符不同时，前一个字符相同则只需查遍上一个字符相匹配的字符的后一个字符是否相同，看看是否有更短的前后缀</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">next</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">kmp_search</span>(<span class="hljs-params">string,patt</span>): <span class="hljs-comment">#时间复杂度为 O（n）</span><br><span class="hljs-built_in">next</span> = build_next(patt)<br>    <br>    i = <span class="hljs-number">0</span> <span class="hljs-comment">#主串中的指针</span><br>    j = <span class="hljs-number">0</span> <span class="hljs-comment">#字串中的指针</span><br>    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(string):<br><span class="hljs-keyword">if</span> string[i] == patt[j]: <span class="hljs-comment">#字符串匹配，指针后移</span><br>            i += <span class="hljs-number">1</span><br>        j += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> j &gt; <span class="hljs-number">0</span>: <span class="hljs-comment">#字负匹配失败，根据 next 跳过字串前面的一些字符</span><br>            j = <span class="hljs-built_in">next</span>[j-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">else</span>: <span class="hljs-comment"># 子串第一个字符匹配失败</span><br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> j == <span class="hljs-built_in">len</span>(patt): <span class="hljs-comment">#匹配成功</span><br>            <span class="hljs-keyword">return</span> i-j<br>        <br></code></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">strStr</span>(<span class="hljs-params">self, haystack, needle</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type haystack: str</span><br><span class="hljs-string">        :type needle: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">build_next</span>(<span class="hljs-params">patt</span>):<br>            <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">            计算 Next数组</span><br><span class="hljs-string">            &#x27;&#x27;&#x27;</span><br>            <span class="hljs-built_in">next</span> = [<span class="hljs-number">0</span>] <span class="hljs-comment"># next 数组(初值元素为0)</span><br>            prefix_len = <span class="hljs-number">0</span> <span class="hljs-comment"># 当前共同前后缀的长度</span><br>            i = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(patt):<br>                <span class="hljs-keyword">if</span> patt[prefix_len] == patt[i]:  <span class="hljs-comment">#如果下个字符相同 即可构成更长度的前后缀</span><br>                    prefix_len += <span class="hljs-number">1</span><br>                    <span class="hljs-built_in">next</span>.append(prefix_len)<br>                    i += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> prefix_len == <span class="hljs-number">0</span>:<br>                        <span class="hljs-built_in">next</span>.append(<span class="hljs-number">0</span>) <span class="hljs-comment">#当查表后，依然不存在相应的 数值，则将对应next设为0</span><br>                        i += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        prefix_len = <span class="hljs-built_in">next</span>[prefix_len - <span class="hljs-number">1</span>] <br>                        <span class="hljs-comment"># 当下一个字符不同时，查遍看看是否有更短的前后缀</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">next</span><br>        <span class="hljs-built_in">next</span> = build_next(needle)<br>    <br>        i = <span class="hljs-number">0</span> <span class="hljs-comment">#主串中的指针</span><br>        j = <span class="hljs-number">0</span> <span class="hljs-comment">#字串中的指针</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(haystack):<br>            <span class="hljs-keyword">if</span> haystack[i] == needle[j]: <span class="hljs-comment">#字符串匹配，指针后移</span><br>                i += <span class="hljs-number">1</span><br>                j += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> j &gt; <span class="hljs-number">0</span>: <span class="hljs-comment">#字负匹配失败，根据 next 跳过字串前面的一些字符</span><br>                j = <span class="hljs-built_in">next</span>[j-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">else</span>: <span class="hljs-comment"># 子串第一个字符匹配失败</span><br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> j == <span class="hljs-built_in">len</span>(needle): <span class="hljs-comment">#匹配成功</span><br>                <span class="hljs-keyword">return</span> i-j<br>        <span class="hljs-keyword">if</span> needle <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> haystack:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Adaptive-Normalization-for-Non-stationary-Time-Series-Forecasting:-A Temporal-Slice-Perspective-文献阅读</title>
    <link href="/2024/03/25/Adaptive-Normalization-for-Non-stationary-Time-Series-Forecasting-A-Temporal-Slice-Perspective-%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    <url>/2024/03/25/Adaptive-Normalization-for-Non-stationary-Time-Series-Forecasting-A-Temporal-Slice-Perspective-%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>数据来源：<a href="https://github.com/zhouhaoyi/ETDataset">https://github.com/zhouhaoyi/ETDataset</a></p><p><a href="https://archive.ics.uci.edu/ml/datasets/ElectricityLoadDiagrams20112014">https://archive.ics.uci.edu/ml/datasets/ElectricityLoadDiagrams20112014</a> </p><p><a href="https://github.com/laiguokun/multivariate-time-series-data">https://github.com/laiguokun/multivariate-time-series-data</a> </p><p><a href="http://pems.dot.ca.gov/">http://pems.dot.ca.gov</a> </p><p><a href="https://www.bgc-jena.mpg.de/wetter/">https://www.bgc-jena.mpg.de/wetter/</a> </p><p><a href="https://gis.cdc.gov/grasp/fluview/fluportaldashboard.html">https://gis.cdc.gov/grasp/fluview/fluportaldashboard.html</a> </p><p><a href="https://github.com/cure-lab/LTSF-Linear">https://github.com/cure-lab/LTSF-Linear</a> </p><p><a href="https://github.com/cure-lab/SCINet">https://github.com/cure-lab/SCINet</a></p><h1 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h1><p>【为克服】 使用不适当的统计量进行归一化  【导致的】 输入序列的每个切片的本能模式被破坏，以及未来统计量的不良估计而导致最终预测结果的预测偏移。</p><p>【提出了】 一个用于非平稳时间序列预测的通用归一化框架- -切片自适应归一化 （Slicing Adaptive Normalization  SAN）</p><hr><p>【导致】 不适当统计量的 【原因】：</p><p>【一方面】  现有的大多数方法忽略了输入序列和 horizon series 之间的分布差异，简单地利用输入序列的统计特性来非正则处理输出结果。</p><p>【此外】先前的研究假设在归一化过程中，同一实例内的所有时间点具有相同的统计特性，全局实例归一化被广泛应用。 </p><p>例：<img src="/.././picture/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240325145939.png" alt="微信截图_20240325145939"></p><center style="color:#C0C0C0;text-decoration:underline">能源消费量及其日均值( MeanByDay )的预测实例说明,还将输入序列的均值和horizon series的均值绘制在图中。.jpg</center><p>尽管在时间上相关，但输入序列的均值与 horizon series 的显著( 075 ~ 1 . 5)不同，表明存在潜在的普遍分布差异。</p><hr><h1 id="方法简述"><a href="#方法简述" class="headerlink" title="方法简述"></a>方法简述</h1><p>【首先】  将输入序列分割成互不重叠的等大小切片</p><p>【然后】  根据其统计特性对切片进行归一化处理，并将其输入到预测模型中。</p><p>【同时】  使用一个统计量预测模块，根据输入的统计量来预测未来切片的分布。</p><p>【最后】  利用估计良好的统计量将非平稳信息还原为预测模型的输出。</p><h2 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h2><p>统计量预测模块独立地模拟统计量的演化趋势，SAN采用了更精确的统计量进行自适应的非正规化。</p><p>【因此】 非平稳预测任务实际上被简化为统计预测和平稳预测。</p><p>【此外】  SAN是一个模型无关的框架，可以应用于任意的预测模型。在一个广泛使用的基准数据集上进行了充分的实验。</p><p>【实验结果表明】SAN优于先进的归一化方法，大幅度地提高了各种主流预测模型的性能。</p><hr><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><blockquote><p>对输入序列的每个切片进行归一化去除非平稳因子，通过非归一化以去除非平稳因子，再通过归一化将其恢复到输出序列</p><blockquote><p>基于间跨度T 将输入序列 x^i^ 分成 M 个 非重叠切片 {x^i^ <del>j</del>}^M^ <del>j&#x3D;1</del></p><p>每个切片的均值和标准差计算如下：</p><p><img src="/.././picture/image-20240326155343938.png" alt="image-20240326155343938"></p><p>其中μ^i^ <del>j</del> ,σ^i^ <del>j</del> ∈ R^V*l^   , x^i^ <del>j,t</del> 是 切片x^i^ <del>j</del>  在t时间步长的值。</p><p>通过原始输出谢列的每个切片的单独统计信息进行归一化，公式如下：</p><p><img src="/.././picture/image-20240326160000454.png" alt="image-20240326160000454"></p><p>ε 是一个小常数</p><p>将每个切片归一化后，再按其原始时间顺序回复所有切片，并让没有非平稳因子的处理序列成为模型的新输入</p></blockquote><p>统计预测模块</p><p><img src="/../picture/image-20240327153423905.png" alt="image-20240327153423905"></p><blockquote><p>SAN为两阶段模型</p><p>第一阶段：它首先将统计量预测模块优化为收敛( lsp )，它根据切片输入均值μ^i^和标准差σ^i^来学习预测未来的统计量。将预测的未来统计量用来训练网络，将得出的输出的<img src="/../picture/97ee0efdff4fc9325a900de94182e0f.png" alt="97ee0efdff4fc9325a900de94182e0f">进行非规范化处理的得到<img src="/../picture/image-20240328160521879.png" alt="image-20240328160521879"></p><p>第二阶段 ：传统的训练预测模型的过程( lfc )，其中统计预测模块被冻结并作为插件功能。</p><blockquote><p>认为输入序列的总体均值ρ^i^为目标序列的均值  的极大似然估计</p><p><img src="/../picture/image-20240327155311544.png" alt="image-20240327155311544"></p><center style="color:#C0C0C0;text-decoration:underline">输入序列的总体均值.jpg</center><p><img src="/../picture/image-20240327155355420.png" alt="image-20240327155355420"></p><center style="color:#C0C0C0;text-decoration:underline">目标序列的总体均值.jpg</center><p>基于上述假设 在该方法中引入残差学习技术，让模块学习未来切片均值( μ^i^)与整体输入均值ρ^i^之间的差值，而不是预测具体的值。这种方法降低了在事先知道未来趋势的情况下对均值建模的难度。此外为消除量纲的影响，设置W1,W2∈ R^V^  作为一维向量表示每个变量的权重。</p><p>统计预测过程可以表述为：</p><p><img src="/../picture/image-20240327161044223.png" alt="image-20240327161044223"></p><p>μ^i^&#x3D; [μ^i^ <del>1</del>, μ^i^ <del>2</del>… μ^i^ <del>M</del>]∈ R^V*M^ 表示输入的M个切片的所有均值。</p><p><img src="/../picture/image-20240327161905032.png" alt="image-20240327161905032">代表未来K个切片的预测均值。同样的记法对标准差起作用。</p><p>预测统计量与真实值之间的均方误差( MSE )作为损失函数( lsp )，通过反向传播来训练网络。</p><p>根据预测模型得出输出<img src="/../picture/97ee0efdff4fc9325a900de94182e0f.png" alt="97ee0efdff4fc9325a900de94182e0f">首先将其拆分为K个不重叠的切片：<img src="/../picture/image-20240328160843262.png" alt="image-20240328160843262"> 进行非规范化处理，公式如下：</p><p><img src="/../picture/image-20240328160712695.png" alt="image-20240328160712695"></p><p>最后按时间顺序恢复所有切片，可以得到整个框架的最终预测<img src="/../picture/image-20240328161013160.png" alt="image-20240328161013160">被用于之后的损耗计算（lfc）和性能评估、</p><p>虽然整体框架明了，但培训过程需要仔细考虑，由于SAN的归一化流程是主干模型的约束，因此整个学习过程实际上是一个双层次优化问题。上层的目标是时间序列预测的性能，而下层的目标是非规范化输出和地面实况之间的分布相似性。从形式上讲，原始的整体培训过程可以描述为：</p><p><img src="/../picture/image-20240328162148820.png" alt="image-20240328162148820"></p><p>（为简洁起见，省略了数据的转换过程，只保留了计算所需的原始输入）</p><p>使用随机梯度下降法得出φ^*^ 最优解</p><p>这将原来的非平稳预测任务解耦为统计预测任务和稳态预测任务。在实践中，统计预测模块首先被训练成收敛，然后在训练预测模型的第二阶段被冻结并被视为插件。</p></blockquote></blockquote></blockquote><hr><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>使用多种数据。</p><img src="../picture/image-20240331180908767.png" alt="image-20240331180908767" style="zoom:80%;" /><p>按照时间顺序将每个数据集分为训练集、验证集和测试集。ETT数据集的分割比为6：2：2，其他数据集的分割比为7：1：2。</p><p>SAN 是一个与模型无关的框架，可应用于任意时间序列预测模型。为了证明该框架的有效性，本文选择了一些基于不同架构的主流模型，并评估了它们在多变量和单变量设置下的性能：基于线性模型的DLinear ，基于Transformer的Autoformer 和FEDformer ，以及基于膨胀卷积的SCINet 。本文呢按照 DLinear9 和 SCINet10 官方代码中提供的实现和设置来实现这些模型。</p><h2 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h2><p>使用ADAM 作为所有实验的默认优化器，并报告均方误差（MSE）和平均绝对误差（MAE）作为评估指标。较低的 MSE&#x2F;MAE 表示性能越好。对于SAN中的统计预测模块，为了简单起见，我们使用了一个简单的两层感知器网络，其隐藏大小与骨干模型的嵌入大小相同。</p><h3 id="切片长度"><a href="#切片长度" class="headerlink" title="切片长度"></a>切片长度</h3><p>切片长度的选择采用了启发式的方法，</p><p>即现实世界的时间序列数据在人为定义或实际时间段（每天、每周等）内表现出类似的变化模式。通过梳理基准数据集的频率，本文建立了一个 {6， 12， 24， 48} 的切片长度范围，以便大多数设置涵盖有意义的时间跨度。例如，本文为 ETTh1、电力和交通等数据集选择了 24 的切片长度，频率为 1 小时。这确保了每个时间片在一天内包含数据，并保证了候选人之间的最佳表现。在这里，我们承认我们方法的一个局限性是当前设计无法处理不可分割的长度，因此我们将切片长度设置为 6，这大约代表每周周期，而不是 Exchange 数据集中的 7。</p><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><p>实验最佳结果用粗体表示</p><img src="../picture/1bb4a4118783bd23801bc4d2c343c68.png" alt="1bb4a4118783bd23801bc4d2c343c68" style="zoom: 67%;" /><center style="color:#C0C0C0;text-decoration:underline">多变量设置下的预测误差。.jpg</center><img src="../picture/5c7aac95684ff88509fdd7d9179ca4f.png" alt="5c7aac95684ff88509fdd7d9179ca4f" style="zoom:67%;" /><center style="color:#C0C0C0;text-decoration:underline">SAN 与现有规范化方法的比较.jpg</center><p>清楚地发现，在基准数据集的大多数情况下，SAN框架可以大大提升这些模型。</p><p>本文将这种改进归因于两个方面。</p><p>【首先】SAN减轻了非平稳因素的影响，正如三个典型的非平稳数据集（Exchange、ILI和ETTh2，由ADF测试结果确定）的性能所证明的那样。</p><p>【其次】 即使在长期预测场景中，预测的难度随着预测时间的延长而显著增加，SAN 也会施加约束。</p><p>将SAN模型与的三种最先进的归一化方法：RevIN 、非平稳变压器 （NST） 和 Dish-TS ，根据相同的实验设置进行比较。将SAN模型归一化的方法和其他归一化方法运用到Autoformer和FEDformer模型上，对每个数据集的所有预测长度上的平均MSE评估以及相对改进。</p><p>【结论】 SAN在现有的归一化方法中实现了最佳性能。比较表明，SAN在从时间切片的角度去除非平稳因素方面可能更有效，而不是考虑整个实例。此外，提出的两阶段训练模式至关重要，因为它使 SAN 的性能大大优于 Dish-TS，而 Dish-TS 忽略了双级优化的性质。然而，SAN的这种特殊能力可能会导致过度平稳化问题[25]，导致天气数据集的性能下降。</p><h2 id="预测结果"><a href="#预测结果" class="headerlink" title="预测结果"></a>预测结果</h2><p>下图显示了使用 FEDformer 作为主干的 ETTm2 数据集上的示例预测，并具有 SAN、RevIN、NST 或 Dish-TS 增强功能。<img src="/../picture/image-20240331192350349.png" alt="image-20240331192350349"></p><p>输入长度为 96，预测长度设置为 336。很明显，SAN 可以生成更现实的预测。</p><p>本文猜测 RevIN 和 NST 的质量差是由它们粗略的非规范化方式引起的。尽管输入序列的平均值可以被视为未来数据的最大似然估计，但与输入相比，非平稳数据集的分布可能会发生重大变化。</p><p>因此，简单地使用输入序列统计量对主干模型的输出进行非规范化处理可能会导致不匹配，就像在 RevIN 和 NST 预测中看到的那样，这两个量表相似。</p><p>至于Dish-TS，该方法虽然试图学习未来分布，但它忽略了双层优化的性质，其纠缠的学习模式限制了统计的估计精度，最终导致性能不佳。</p><p>【相反】SAN从切片的角度对时间序列的动态性质进行建模，并引入了一个独立的统计预测模块，以学习通过两阶段训练模式来预测未来非规范化的分布。通过这种方式，我们根据统计预测自适应地调整预测结果的规模和偏差，捕捉未来数据的趋势。因此，尽管输入的平均值相当低，但 SAN 仍会产生与实际情况一致的更高预测。</p><h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><p><img src="/../picture/a5d2e8d4498d126156053330a554543.png" alt="a5d2e8d4498d126156053330a554543"></p>]]></content>
    
    
    
    <tags>
      
      <tag>文献阅读</tag>
      
      <tag>非平稳时间序列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>比较操作符</title>
    <link href="/2024/03/21/%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6-title/"/>
    <url>/2024/03/21/%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6-title/</url>
    
    <content type="html"><![CDATA[<p>Python包含了一系列的魔法方法，用于实现对象之间直接比较，而不需要采用方法调用。同样也可以重载Python默认的比较方法，改变它们的行为。下面是这些方法的列表：</p><ul><li><code>__cmp__</code>(self, other)<br><code>__cmp__</code> 是所有比较魔法方法中最基础的一个，它实际上定义了所有比较操作符的行为（&lt;,&#x3D;&#x3D;,!&#x3D;,等等），但是它可能不能按照你需要的方式工作（例如，判断一个实例和另一个实例是否相等采用一套标准，而与判断一个实例是否大于另一实例采用另一套）。<code>__cmp__</code> 应该在 self &lt; other 时返回一个负整数，在 self &#x3D;&#x3D; other 时返回0，在 self &gt; other 时返回正整数。最好只定义你所需要的比较形式，而不是一次定义全部。如果你需要实现所有的比较形式，而且它们的判断标准类似，那么 <code>__cmp__</code> 是一个很好的方法，可以减少代码重复，让代码更简洁。</li><li><code>__eq__</code>(self, other)<br>定义等于操作符(&#x3D;&#x3D;)的行为。</li><li><code>__ne__</code>(self, other)<br>定义不等于操作符(!&#x3D;)的行为。</li><li><code>__lt__</code>(self, other)<br>定义小于操作符(&lt;)的行为。</li><li><code>__gt__</code>(self, other)<br>定义大于操作符(&gt;)的行为。</li><li><code>__le__</code>(self, other)<br>定义小于等于操作符(&lt;)的行为。</li><li><code>__ge__</code>(self, other)<br>定义大于等于操作符(&gt;)的行为。</li></ul><p>选自：<a href="https://zhuanlan.zhihu.com/p/134649090">非常全的通俗易懂 Python 魔法方法指南（上） - 知乎 (zhihu.com)</a></p><p>例：<a href="https://leetcode.cn/problems/merge-k-sorted-lists/solutions/2384305/liang-chong-fang-fa-zui-xiao-dui-fen-zhi-zbzx/">23. 合并 K 个升序链表 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ListNode.__lt__ = <span class="hljs-keyword">lambda</span> a, b: a.val &lt; b.val  <span class="hljs-comment"># 让堆可以比较节点大小</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小堆</title>
    <link href="/2024/03/19/%E6%9C%80%E5%B0%8F%E5%A0%86-title/"/>
    <url>/2024/03/19/%E6%9C%80%E5%B0%8F%E5%A0%86-title/</url>
    
    <content type="html"><![CDATA[<h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><p>力扣第23题：合并k个升序链表</p><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">输入：lists = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：链表数组如下：<br>[<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br>  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br>将它们合并到一个有序链表中得到。<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">输入：lists = []<br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">输入：lists = [[]]<br>输出：[]<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">23. 合并 K 个升序链表 - 力扣（LeetCode）</a></p><h2 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h2><p>定义：<br>1、堆是一颗完全二叉树；</p><p>2、堆中的某个结点的值总是大于等于（最大堆）或小于等于（最小堆）其孩子结点的值。</p><p>3、堆中每个结点的子树都是堆树。</p><p><img src="/../picture/70" alt="img"><img src="/../picture/80" alt="img"></p><h2 id="python-heapq库"><a href="#python-heapq库" class="headerlink" title="python heapq库"></a>python heapq库</h2><p>最小堆的编写用到heapq库,堆的使用一般用于排序</p><p><a href="https://docs.python.org/zh-cn/3/library/heapq.html">heapq — 堆队列算法 — Python 3.12.2 文档</a></p><h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><p>res.append(path)相当于append进去path的引用，如果你此时改path，那么res里面的结果也会变，这两是指向同一个对象的。path[:]相当于重新赋值了一个对象</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/03/18/hello-world/"/>
    <url>/2024/03/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
