<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>回溯算法</title>
    <link href="/2024/04/20/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2024/04/20/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="回溯算法与深度优先遍历"><a href="#回溯算法与深度优先遍历" class="headerlink" title="回溯算法与深度优先遍历"></a>回溯算法与深度优先遍历</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>回溯法</strong>采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p><blockquote><p>1、找到一个可能存在的正确的答案；<br>2、在尝试了所有可能的分步方法后宣告该问题没有答案。</p></blockquote><p><strong>深度优先搜索</strong>算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会<strong>尽可能深</strong>的搜索树的分支。当结点 v 的所在边都己被探寻过，搜索将<strong>回溯</strong>到发现结点 v 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。</p><h2 id="与动态规划的区别"><a href="#与动态规划的区别" class="headerlink" title="与动态规划的区别"></a>与动态规划的区别</h2><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>用于求解多阶段决策问题。多阶段决策问题即：</p><blockquote><p>1、求解一个问题分为很多步骤（阶段）</p><p>2、每一个步骤（阶段）可以有多种选择。</p></blockquote><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><blockquote><p>1、动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果；<br>2、回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。</p></blockquote><p><img src="/../picture/image-20240420122345034.png" alt="image-20240420122345034"></p><p>说明：</p><p>每一个结点表示了求解全排列问题的不同的阶段，这些阶段通过变量的「不同的值」体现，这些变量的不同的值，称之为「状态」；<br>使用深度优先遍历有「回头」的过程，在「回头」以后， 状态变量需要设置成为和先前一样 ，因此在回到上一层结点的过程中，需要撤销上一次的选择，这个操作称之为「状态重置」；<br>深度优先遍历，借助系统栈空间，保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 path 变量是一个栈；<br>深度优先遍历通过「回溯」操作，实现了全局使用一份状态变量的效果。<br>使用编程的方法得到全排列，就是在这样的一个树形结构中完成 遍历，从树的根结点到叶子结点形成的路径就是其中一个全排列。</p><p>设计状态变量<br>首先这棵树除了根结点和叶子结点以外，每一个结点做的事情其实是一样的，即：在已经选择了一些数的前提下，在剩下的还没有选择的数中，依次选择一个数，这显然是一个 递归 结构；<br>递归的终止条件是： 一个排列中的数字已经选够了 ，因此我们需要一个变量来表示当前程序递归到第几层，我们把这个变量叫做 depth，或者命名为 index ，表示当前要确定的是某个全排列中下标为 index 的那个数是多少；<br>布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 true ，这样在考虑下一个位置的时候，就能够以 O(1)O(1)O(1) 的时间复杂度判断这个数是否被选择过，这是一种「以空间换时间」的思想。<br>这些变量称为「状态变量」，它们表示了在求解一个问题的时候所处的阶段。需要根据问题的场景设计合适的状态变量。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散傅里叶变换</title>
    <link href="/2024/04/14/%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    <url>/2024/04/14/%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="离散傅里叶变换的作用"><a href="#离散傅里叶变换的作用" class="headerlink" title="离散傅里叶变换的作用"></a>离散傅里叶变换的作用</h1><p>将时间域信号分解为构成它的频率成分，以此获得频率信息（振幅谱、功率谱和功率谱密度）可以获得我们无法从时间域获得的对信号的一些洞察。</p><p>离散傅里叶变换（DFT）便是帮助我们获得这些表示的第一步。</p><p>DFT将信号（时间域）或距离（空间域）转换到频率域。</p><blockquote><p>可以通过转换找到原本域内不明显的信号特征</p></blockquote><h1 id="离散傅里叶变换的公式"><a href="#离散傅里叶变换的公式" class="headerlink" title="离散傅里叶变换的公式"></a>离散傅里叶变换的公式</h1><p>$$<br>X_k &#x3D; \sum_{n&#x3D;0}^{N-1}{x_n}e^{-i\frac{2\pi}{N}kn}<br>$$</p><p>x<del>n</del> 为离散时间域信号  ✖ 复数为e的指数<br>$$<br>e^{-i\frac{2\pi}{N}kn} \<br>e^{-in}  &#x3D; cos(n)+isin(n)<br>$$<br>即可看作将时间信号✖特定频率的正弦和余弦 ，由变量k给出，再将结果求和。</p><p>可对不同的频率和不同的k值进行求和。</p><p>离散傅里叶变换仍旧是时域到频域的变换。由于求和形式的特殊性，可以有其他的解释方法。</p><p>如果把序列x<del>n</del>看作多项式f(x)的x^n^项系数，则计算得到的X<del>K</del> 恰好是多项式 f (x)代入单位根$e^{-i\frac{2\pi}{N}k} \$的点值$f(e^{-i\frac{2\pi}{N}k}\$） 。</p><p>这便构成了卷积定理的另一种解释办法，即对多项式进行特殊的插值操作。离散傅里叶变换恰好是多项式在单位根处进行插值。</p><p>例如计算：</p><p>${n\choose 3} + {n\choose 7} +{n\choose 11}+{n\choose 15}+…… $</p><p>定义函数f(x)为：</p><p>$$f(x) &#x3D; (1+x)^n &#x3D; {n\choose 0}x^0 + {n\choose 1}x^1 +{n\choose 2}x^2+{n\choose 3}x^3+…… $$</p><p>然后可以发现，代入四次单位根 f(i)得到这样的序列：</p><p>$f(i) &#x3D; (1+i)^n&#x3D;{n\choose 0} + {n\choose 1}i -{n\choose 2}x^2-{n\choose 3}i+……$</p><p>于是下面的求和恰好可以把其余各项消掉：</p><p>$f(1) + if(i) - f(-1) -if(-1) &#x3D; 4{n\choose 3} + 4{n\choose 7} +4{n\choose 11}+4{n\choose 15}+…… $</p><p>因此这道数学题的答案为：</p><p>${n\choose 3} + {n\choose 7} +{n\choose 11}+{n\choose 15}+…… &#x3D; \frac{2^n+i(1+i)^n-i(1-i)^n}4 $</p><p>这道数学题在单位根处插值，恰好构成离散傅里叶变换。</p><blockquote><p><img src="/../picture/image-20240415165513671.png" alt="image-20240415165513671"></p><p>复平面中的<strong>单位圆</strong><img src="/../picture/v2-9f362e80d8a3ede0e575fc3ea2b05fb2_720w.webp" alt="img"></p><p>其中向量OA单位根，表示为 $e^i\theta$，可知 $e^i\theta &#x3D; cos\theta+isin\theta$</p><p>将单位圆等分成 n个部分（以单位圆与实轴正半轴的交点一个等分点），以原点为起点，圆的这 n 个 n等分点为终点，作出 n个向量。</p><p>其中<strong>幅角为正且最小</strong>的向量称为 n次单位向量，记为$\omega_n^1 $。</p><p>其余的 n−1 个向量分别为$\omega_n^2,\omega_n^3,……，\omega_n^n$ ，它们可以由复数之间的乘法得来$\omega_n^k&#x3D;\omega_n^k-*\omega_n^1$ </p><p>易得 $\omega_n^n&#x3D;\omega_n^0&#x3D;1$</p></blockquote><p><strong>可把DFT看作时间信号和许多频率之间产生相关性</strong></p><p><img src="/../picture/image-20240414164437538.png" alt="image-20240414164437538"></p><p><strong>还可以看作矩阵乘法的旋转</strong></p><p><img src="/../picture/image-20240414165107652.png" alt="image-20240414165107652"></p><p> X<del>0</del> 为时间信号与k&#x3D;0 的内积以此类推</p><h1 id="快速傅里叶变换（Fast-Fourier-Transform-FFT）"><a href="#快速傅里叶变换（Fast-Fourier-Transform-FFT）" class="headerlink" title="快速傅里叶变换（Fast Fourier Transform, FFT）"></a>快速傅里叶变换（Fast Fourier Transform, FFT）</h1><p><strong>快速傅里叶变换</strong> (Fast Fourier Transform, FFT) 是一种可在O(nlogn)时间内完成的 离散傅里叶变换(Discrete Fourier transform, DFT) 算法.</p><p>傅里叶变换 (Fourier Transform) 本质上是信号与三角函数进行卷积运算，而快速傅里叶变换 (FFT) 就是提高卷积的计算效率，时间复杂度从 O(n^2^) 降低到 O(nlogn)</p><p><strong>FFT</strong> 在算法中主要是用来在算法中的运用主要是用来加速<strong>多项式乘法</strong>或<strong>大数乘法</strong></p><h2 id="多项式乘法"><a href="#多项式乘法" class="headerlink" title="多项式乘法"></a>多项式乘法</h2><p>考虑两个多项式 **A(x)<strong>，</strong>B(x) **，其乘积 **C(x) &#x3D; A(x) * B(x) **</p><p>假设 <strong>A(x)</strong> 的项数为 n，其系数构成的 n维向量为 (a<del>0</del>,a<del>1</del>,a<del>2</del>,⋯,a<del>n−1</del>) ； B(x) 的项数为 m ，其系数构成的 m维向量为 (b<del>0</del>,b<del>1</del>,b<del>2</del>,⋯,b<del>n−1</del>)。</p><p>我们要求<strong>C(x)</strong> 的系数构成的n+m-1维的向量，先考虑暴力做法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-built_in">len</span>(A)<br>m = <span class="hljs-built_in">len</span>(B)<br>C = [<span class="hljs-number">0</span>]*(m+n-<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        C[i+j] = A[i] * B[j]<br>      <br></code></pre></td></tr></table></figure><p>可见时间复杂度是 O(n^2^) 。</p><p>实际运用中多项式的项数非常多，比如 10^5^ 这种级别，那么有没有什么方法可以加速运算呢？</p><p>已知在一组插值节点 (x^0^,x^1^,x^2^,⋯,x^n^)中 ，假设<strong>A(x)<strong>，</strong>B(x)</strong> 为多项式的项数相同。 **A(x)<strong>，</strong>B(x)**的点值向量分别为(y<del>a0</del>,y<del>a1</del>,y<del>a2</del>,⋯,y<del>an</del>) ，(y<del>b0</del>,y<del>b1</del>,y<del>b2</del>,⋯,y<del>bn</del>) ,则：</p><p>$A(x) &#x3D; (x_0,y_{a0}),(x_1,y_{a1}),(x_2,y_{a2})，……，(x_n,y_{an})$</p><p>$B(x) &#x3D;  (x_0,y_{b0}),(x_1,y_{b1}),(x_2,y_{b2})，……，(x_n,y_{bn})$</p><p>$ C(x) &#x3D;(x_0,y_{a0}·y_{b0}),(x_1,y_{a1}·y_{b1}),(x_2,y_{a2}·y_{b2})，……，(x_n,y_{an}·y_{bn}) $</p><p>那么 <strong>C(x) &#x3D; A(x) ⋅ B(x) <strong>，那么其</strong>点值表示法</strong>可以在 O(n) 的时间内求出</p><blockquote><h1 id="点值表示法"><a href="#点值表示法" class="headerlink" title="点值表示法"></a>点值表示法</h1><p>点值表示法是把这个多项式看成一个函数，从其中选取 n 个不同的点，从而利用这 n 个点来唯一地表示这个函数</p><p>设</p><p>$A(x_0) &#x3D; y_0 &#x3D; a_0 +a_1x_0+a_2x_0^2+a_3x_0^3+……+a_{n-1}x_0^{n-1}$</p><p>$A(x_1) &#x3D; y_1 &#x3D; a_0 +a_1x_1+a_2x_1^2+a_3x_1^3+……+a_{n-1}x_1^{n-1}$</p><p>$A(x_2) &#x3D; y_2 &#x3D; a_0 +a_1x_2+a_2x_2^2+a_3x_2^3+……+a_{n-1}x_2^{n-1}$</p><p>………………</p><p>$A(x_n) &#x3D; y_n &#x3D; a_0 +a_1x_n+a_2x_n^2+a_3x_n^3+……+a_{n-1}x_n^{n-1}$</p><p>那么用点值表示法表示 A(x) 如下：</p><p>$ A(x)&#x3D; a_0 +a_1x+a_2x^2+a_3x^3+……+a_{n-1}x^{n-1}  ⇔ A(x)&#x3D;(x_0,y_{0}),(x_1,y_{1}),(x_2,y_{2})，……，(x_n,y_{n})$</p></blockquote><p>可以观察到，多项式乘法的系数表示法就是做<strong>卷积运算</strong>，而点值表示法是做<strong>乘法运算</strong>。卷积定理告诉我们在一个域中的卷积相当于另一个域中的乘积。</p><p>在这里，系数表示法就是时域上表达，很复杂，而点值表示法就是频域上表示，就非常简单。那么我们将其转换为频域上表示，就可以大大降低其复杂度！</p><p>此时我们可以把快速傅里叶变换（FFT）看作是一个黑匣子，我们先向黑匣子输入<strong>A(x) ，B(x) ** 系数表达式，黑匣子内部先将</strong>A(x) ,B(x) ** 都变成点值表达式，黑匣子进行乘法运算后，再在内部转换为系数表达式.</p><h2 id="FFT算法"><a href="#FFT算法" class="headerlink" title="FFT算法"></a>FFT算法</h2><p>FFT算法的基本思想是分治法，将多项式分为奇次项和偶次项处理</p><p>$ A(x)&#x3D; a_0 +a_1x+a_2x^2+a_3x^3+……+a_{n-1}x^{n-1} $</p><p>按照次数的奇偶来分成两组，然后提出一个x:</p><p>$A(x) &#x3D;  (a_0 +a_2x^2+a_4x^4+a_6x^6……）+x(a_1 +a_3x^2+a_5x^4+a_7x^6)$</p><p>令</p><p>$H(x) &#x3D; a_0 +a_2x+a_4x^2+a_6x^3+……+a_{n-2}x^{\frac{n-2}2}$</p><p>$G(x) &#x3D; a_1 +a_3x+a_5x^2+a_6x^3+……+a_{n-1}x^{\frac{n-2}2}$</p><p>$A(x) &#x3D; H(x^2)+xG(x^2)$</p><p>因为单位根$\omega_{2n}^{k+n}&#x3D;-\omega_{2n}^k$  即对于偶数次单位根$\omega_{n}^{k+n&#x2F;2}&#x3D;-\omega_{n}^k$ ,和$H(x^2)和G(x^2)$ 是偶函数，分别代如$\omega_{n}^{k+n&#x2F;2}和\omega_{n}^k$ 可得到：</p><p>$$<br>A(\omega_{n}^k) &#x3D; G((\omega_{n}^k)^2)+\omega_{n}^k<em>H((\omega_{n}^k)^2) \<br>&#x3D;G(\omega_{n}^{2k})+\omega_{n}^k</em>H(\omega_{n}^{2k}) \<br>&#x3D;G(\omega_{n&#x2F;2}^k)+\omega_{n}^k*H(\omega_{n&#x2F;2}^k))<br>$$<br>和<br>$$<br>A(\omega_{n}^{k+n&#x2F;2}) &#x3D;<br>G(\omega_{n}^{2k+n})+\omega_{n}^{k&#x2F;2}<em>H(\omega_{n}^{2k+n}) \<br>&#x3D;G(\omega_{n&#x2F;2}^k)-\omega_{n}^k</em>H(\omega_{n&#x2F;2}^k))<br>$$<br>因此我们求出了$G(\omega_{n&#x2F;2}^k)和H(\omega_{n&#x2F;2}^k)$后，就可以同时求出 $A(\omega_{n}^{k+n&#x2F;2})和A(\omega_{n}^k) $。于是对G和H分别递归 DFT 即可。</p><h1 id="离散傅里叶逆变换"><a href="#离散傅里叶逆变换" class="headerlink" title="离散傅里叶逆变换"></a>离散傅里叶逆变换</h1><p>用来实现上文黑匣子的另一半，将多项式点值表达式转换成系数表达式。</p><p>对于多项式$ A(x)&#x3D; a_0 +a_1x+a_2x^2+a_3x^3+……+a_{n-1}x^{n-1} $ ，已知 n个点，其 n维点值向量为$ (A(x_0),A(x_1),A(x_2),……，A(x_n-1))$，请求解其n维系数向量 (a<del>0</del>,a<del>1</del>,a<del>2</del>,⋯,a<del>n−1</del>)？</p><p> 1、设 (d<del>0</del>,d<del>1</del>,d<del>2</del>,⋯,d<del>n−1</del>)为 (a<del>0</del>,a<del>1</del>,a<del>2</del>,⋯,a<del>n−1</del>)得到的离散傅里叶变换的结果。</p><p> 构造多项式：</p><p> $F(x) &#x3D; d_0+d_1x+d_2x^2+……+d_{n-1}x^{n-1}$</p><p> 2、设向量$（c_0,c_1,……,c_{n-1}）$,其中c<del>k</del> 为F(x) 在$x&#x3D;\omega_{n}^{-k}$的点值表示，即</p><p>$$<br>c_k &#x3D; \sum_{n&#x3D;0}^{n-1}{d_i}(\omega_{n}^{-k})^i<br>$$</p><p>代入 $d_i &#x3D; \sum_{j&#x3D;0}^{n-1}{a_j}(\omega_{n}^{i})^j$得</p><p>$$<br>c_k &#x3D; \sum_{n&#x3D;0}^{n-1}{[\sum_{j&#x3D;0}^{n-1}{a_j}(\omega_{n}^{i})^j]}(\omega_{n}^{-k})^i<br>$$</p><p> 所以<br>$$<br>c_k &#x3D; \sum_{j&#x3D;0}^{n-1}a_j{\sum_{i&#x3D;0}^{n-1}}(\omega_{n}^{i})^{j-k}<br>$$<br> 令$S(j,k)&#x3D;{\sum_{i&#x3D;0}^{n-1}}(\omega_{n}^{i})^{j-k}$,对其简化：</p><p>设$j-k&#x3D;\delta$<br>$$<br>S(j,k)&#x3D;\omega_{n}^{0}+\omega_{n}^{\delta}+\omega_{n}^{2\delta}+……+\omega_{n}^{(n-1)\delta}<br>$$<br>可见$\omega_{n}^{k}$为等比数列，其公比为$\omega_{n}^{\delta}$</p><blockquote><p>当$\omega_{n}^{\delta}&#x3D;1$即$\delta&#x3D;0$时，$S(j,k)&#x3D;n$,此时 j &#x3D; k；</p><p>当$\omega_{n}^{\delta}  ≠1 $ 即$\delta≠0$时，由等比数列求和公式：</p><p><img src="/../picture/image-20240416163521215.png" alt="image-20240416163521215"></p><p>此时 j  ≠ k</p><p>综合可得S(j,k)&#x3D;[j&#x3D;k]*n</p></blockquote><p>带入原式求a<del>k</del> :<br>$$<br>c_k &#x3D; \sum_{j&#x3D;0}^{n-1}a_jS(j,k)&#x3D;\sum_{j&#x3D;0}^{n-1}a_j[j&#x3D;k]*n &#x3D; a_k *n<br>$$<br>所以**a<del>k</del> &#x3D; c<del>k</del>&#x2F;n **</p><p>参考：</p><p><a href="https://www.longluo.me/blog/2022/04/02/fft/#%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E9%80%86%E5%8F%98%E6%8D%A2inverse-discrete-fourier-transform">快速傅里叶变换(FFT)算法 | Long Luo’s Life Notes</a></p><p><a href="https://zhuanlan.zhihu.com/p/31584464">一小时学会快速傅里叶变换（Fast Fourier Transform） - 知乎 (zhihu.com)</a> </p><p><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2">Wiki: 快速傅里叶变换</a></p><p><a href="https://www.bilibili.com/video/BV1rj41157C6/?spm_id_from=333.880.my_history.page.click&vd_source=2bae94d7b27779814e1b356ab2b75f7e">如何快速理解离散傅立叶变换和FFT_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>理论基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2024/04/09/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2024/04/09/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找理念："><a href="#二分查找理念：" class="headerlink" title="二分查找理念："></a>二分查找理念：</h1><p>左指针left 右指针right  和中间指针 mid &#x3D; (left+right)&#x2F;&#x2F;2 ，通过不断比较中间指针和所需查找的值的大小来调整指针位置。</p><p>注：需注意二分查找的范围 ：【】 【） （）</p><p>和比较符号 &gt;&#x3D;   &gt;   &lt;  &lt;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lower_bound</span>(<span class="hljs-params">nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>  <span class="hljs-comment"># 闭区间 [left, right]</span><br>    <span class="hljs-keyword">while</span> left &lt;= right:  <span class="hljs-comment"># 区间不为空</span><br>        <span class="hljs-comment"># 循环不变量：</span><br>        <span class="hljs-comment"># nums[left-1] &lt; target</span><br>        <span class="hljs-comment"># nums[right+1] &gt;= target</span><br>        mid = (left + right) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &lt; target:<br>            left = mid + <span class="hljs-number">1</span>  <span class="hljs-comment"># 范围缩小到 [mid+1, right]</span><br>        <span class="hljs-keyword">else</span>:<br>            right = mid - <span class="hljs-number">1</span>  <span class="hljs-comment"># 范围缩小到 [left, mid-1]</span><br>    <span class="hljs-keyword">return</span> left  <span class="hljs-comment"># 或者 right+1</span><br><br><span class="hljs-comment"># 左闭右开区间写法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lower_bound2</span>(<span class="hljs-params">nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    left = <span class="hljs-number">0</span><br>    right = <span class="hljs-built_in">len</span>(nums)  <span class="hljs-comment"># 左闭右开区间 [left, right)</span><br>    <span class="hljs-keyword">while</span> left &lt; right:  <span class="hljs-comment"># 区间不为空</span><br>        <span class="hljs-comment"># 循环不变量：</span><br>        <span class="hljs-comment"># nums[left-1] &lt; target</span><br>        <span class="hljs-comment"># nums[right] &gt;= target</span><br>        mid = (left + right) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &lt; target:<br>            left = mid + <span class="hljs-number">1</span>  <span class="hljs-comment"># 范围缩小到 [mid+1, right)</span><br>        <span class="hljs-keyword">else</span>:<br>            right = mid  <span class="hljs-comment"># 范围缩小到 [left, mid)</span><br>    <span class="hljs-keyword">return</span> left  <span class="hljs-comment"># 或者 right</span><br><br><span class="hljs-comment"># 开区间写法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lower_bound3</span>(<span class="hljs-params">nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    left, right = -<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)  <span class="hljs-comment"># 开区间 (left, right)</span><br>    <span class="hljs-keyword">while</span> left + <span class="hljs-number">1</span> &lt; right:  <span class="hljs-comment"># 区间不为空</span><br>        mid = (left + right) // <span class="hljs-number">2</span><br>        <span class="hljs-comment"># 循环不变量：</span><br>        <span class="hljs-comment"># nums[left] &lt; target</span><br>        <span class="hljs-comment"># nums[right] &gt;= target</span><br>        <span class="hljs-keyword">if</span> nums[mid] &lt; target:<br>            left = mid  <span class="hljs-comment"># 范围缩小到 (mid, right)</span><br>        <span class="hljs-keyword">else</span>:<br>            right = mid  <span class="hljs-comment"># 范围缩小到 (left, mid)</span><br>    <span class="hljs-keyword">return</span> right  <span class="hljs-comment"># 或者 left+1</span><br><br>作者：灵茶山艾府<br>链接：https://leetcode.cn/problems/search-insert-position/solutions/<span class="hljs-number">2023391</span>/er-fen-cha-zhao-zong-shi-xie-bu-dui-yi-g-nq23/<br>来源：力扣（LeetCode）<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>下一个排列算法</title>
    <link href="/2024/04/01/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95/"/>
    <url>/2024/04/01/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/next-permutation/description/">31. 下一个排列 - 力扣（LeetCode）</a></p><p>找出这个数组排序出的所有数中，刚好比当前数大的那个数</p><p>比如当前 nums &#x3D; [1,2,3]。这个数是123，找出1，2，3这3个数字排序可能的所有数，排序后，比123大的那个数 也就是132</p><p>如果当前 nums &#x3D; [3,2,1]。这就是1，2，3所有排序中最大的那个数，那么就返回1，2，3排序后所有数中最小的那个，也就是1，2，3 -&gt; [1,2,3]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>1、 我们希望下一个数组组成的数比现在的数大，因此只需要从后向前，将后面稍大的数和前面稍小的数交换。例 1234587，因此只需要将5，7进行交换 得出更大的数 1234785</p><blockquote><p>从后向前，查找到第一个i，满足数组a[i] &lt; a[i+1]</p><p>再从[i+1,n)中从后向前找到 第一个元素 j 满足 a[i] &lt; a[j] ,这样较大数 为a[j]  </p></blockquote><p>2、还希望下一个数在其他比原数组成的数中最小。</p><blockquote><p>交换 a[i],a[j],此时可以发现[i+1,n) 必为降序， 因此可以用双指针反转区间，使里面数值便为升序.</p><p>这时 该数组为稍大的数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">nextPermutation</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        i = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">2</span><br>        <span class="hljs-keyword">while</span> i &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] &gt;= nums[i + <span class="hljs-number">1</span>]:<br>            i -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span>:<br>            j = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> j &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] &gt;= nums[j]:<br>                j -= <span class="hljs-number">1</span><br>            nums[i], nums[j] = nums[j], nums[i]<br>        <br>        left, right = i + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            nums[left], nums[right] = nums[right], nums[left]<br>            left += <span class="hljs-number">1</span><br>            right -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>借鉴：<a href="https://leetcode.cn/problems/next-permutation/solutions/479151/xia-yi-ge-pai-lie-by-leetcode-solution/">31. 下一个排列 - 力扣（LeetCode）</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FEDformer: Frequency Enhanced Decomposed Transformer for Long-term Series Forecasting 文献阅读</title>
    <link href="/2024/04/01/FEDformer-Frequency-Enhanced-Decomposed-Transformer-for-Long-term-Series-Forecasting-%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    <url>/2024/04/01/FEDformer-Frequency-Enhanced-Decomposed-Transformer-for-Long-term-Series-Forecasting-%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h1><p>长期时间序列预测在各种应用(例如,能源、天气、交通、经济等)中是一个长期存在的挑战。</p><p>尽管RNN类型的方法( Rangapuram et al., 2018; Flunkert et al., 2017）取得了令人印象深刻的结果，但它们经常遭受梯度消失或爆炸的问题（Pascanu et al., 2013)。极大地限制了它们的性能。继最近在NLP和CV社区((Vaswani et al., 2017; Devlin et al., 2019; Dosovitskiy et al., 2021; Rao et al., 2021)中取得成功之后，Transformer ( Vaswani et al , 2017)被引入到时间序列预测中捕捉长期依赖关系，并显示出有希望的结果( Zhou et al . , 2021 ; Wu et al , 2021)。由于较高的计算复杂度和内存需求使得Transformer难以应用于长序列建模，因此大量研究致力于降低Transformer(Li et al., 2019; Kitaev et al., 2020; Zhou et al., 2021; Wang et al., 2020; Xiong et al., 2021; Ma et al., 2021的计算成本。</p><p>尽管基于Transformer的时间序列预测方法取得了一定的进展，但在某些情况下，它们往往无法捕获时间序列的整体特征&#x2F;分布。在图1中，我们在一个真实的ETTm1数据集(Zhou et al., 2021).中比较了真实时间序列和vanilla Transformer方法(Vaswani et al., 2017)预测的真实时间序列。    </p><p>显然，预测的时间序列具有与真实值不同的分布。真值和预测之间的差异可以用Transformer中的逐点注意和预测来解释。由于每个时间步的预测是单独独立进行的，模型很可能无法从整体上保持时间序列的全局性质和统计量。</p><p><img src="/../picture/image-20240408132927558.png" alt="image-20240408132927558"></p><h1 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h1><p>为了解决每个时间步的预测是单独独立进行的，模型很可能无法从整体上保持时间序列的全局性质和统计量。本文在这项工作中采用了两种思路。</p><p>第一种思路是将时间序列分析中广泛使用的季节趋势分解方法(Cleveland et al., 1990; Wen et al., 2019),纳入Transformer - based方法。尽管这个想法在(Oreshkin et al., 2019; Wu et al., 2021)之前就已经得到了应用，但根据Kologrov-Smirnov分布测试，我们提出了一种特殊的网络设计，可以有效地使预测的分布接近真实值的分布。</p><p>第二个想法是结合傅里叶分析与基于变压器的方法。我们不是将Transformer应用于时域，而是将其应用于频域，这有助于Transformer更好地捕获时间序列的全局属性。</p><p> 本文结合这两种思想，提出了一种用于长期时间序列预测的频率增强分解变换( Frequency Enhance Decomposition Transformer，简称FEDformer )。</p><h1 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h1><p>长期时间序列预测是一个序列到序列的问题。我们将输入长度记为I，输出长度记为O。我们将D记为序列的隐藏状态。编码器的输入是一个I × D矩阵，解码器有( I &#x2F; 2 + O) × D输入。</p><h2 id="FEDformer结构"><a href="#FEDformer结构" class="headerlink" title="FEDformer结构"></a>FEDformer结构</h2><p><img src="/../picture/image-20240414145014389.png" alt="image-20240414145014389"></p><p>包括频率增强块( FEB )、连接编码器和解码器的频率增强注意力( FEA )和混合专家分解块( MOEDecomp )。</p><h4 id="Frequency-Enhanced-Decomposition-Architecture（频率增强分解结构）"><a href="#Frequency-Enhanced-Decomposition-Architecture（频率增强分解结构）" class="headerlink" title="Frequency Enhanced Decomposition Architecture（频率增强分解结构）"></a>Frequency Enhanced Decomposition Architecture（频率增强分解结构）</h4><p>在Autoformer中，分解模块使用的是固定的窗口大小，为了克服固定大小在具有复杂周期和趋势分量的现实情况下的不足，作者设计了一个混合型分解模块，其主要由若干个不同大小的窗口组成，提取到多个不同的分量特征，同时作者还对他们设置了权值，旨在区分不同分量特征对模型的贡献，最终以加权求和的方式获得最终趋势数据。这部分通俗易懂，主要进行了不同尺度的滤波操作获得多种结果，并对他们加权计算最终结果。</p><h4 id="Fourier-enhanced-blocks-and-Wavelet-enhanced-blocks（傅里叶增强模块和小波增强模块）"><a href="#Fourier-enhanced-blocks-and-Wavelet-enhanced-blocks（傅里叶增强模块和小波增强模块）" class="headerlink" title="Fourier enhanced blocks and Wavelet enhanced blocks（傅里叶增强模块和小波增强模块）"></a>Fourier enhanced blocks and Wavelet enhanced blocks（傅里叶增强模块和小波增强模块）</h4><p>在该部分，作者提出将Transformer和傅里叶分析相结合，取代以往将Transformer应用于时间特征提取，改为使用Transformer对傅里叶变换后的频域数据进行特征提取。然而时域数据转化为频域数据带来的是大量的频率分量，是否针对所有数据进行特征提取或者如何选择这些分量将是一个问题。针对这个问题，作者进行了分析和验证。</p><p><em><strong>使用所有频率分量</strong></em> 虽然数据一点不会丢失，但考虑到傅里叶变换的局限性，过多的频率特征带来的将是冗余的信息资源、庞大的机器和时间开销以及过拟合的风险，因此不适用于对所有数据进行特征提取。<br><em><strong>使用部分高频分量</strong></em> 高频分量代表时间序列中变化的突变型特征，确实具有一定的特殊性，然而噪声的存在否定了特殊性存在的合理性，过度地对高频分量进行特征提取，或许模型最终学习到更多噪声的内容，而难以关注时间序列本身。<br><em><strong>使用部分低频分量</strong></em> 低频分量较为平缓，而时间序列中趋势的变化往往与重要事件的发生有关，缺少了高频分量对趋势的影响，时间序列将不具个性，预测的意义也大大降低。<br><em><strong>随机选择分量</strong></em> 作者通过论证得到随机选取分量更有效，大大降低了复杂度。</p><p>该部分内容将被使用在时域转频域后频域分量的选择。<br>该部分借鉴自：<a href="https://blog.csdn.net/qq_43166192/article/details/130186788">https://blog.csdn.net/qq_43166192/article/details/130186788</a></p><h3 id="编码器和解码器"><a href="#编码器和解码器" class="headerlink" title="编码器和解码器"></a>编码器和解码器</h3><p>编码器和解码器都采用多层结构</p><h4 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h4><p>X^l^ <del>en</del>  &#x3D; Encoder(X^l-1^ <del>en</del>) , l∈{1，…….，N}表示第l个编码层的输出，X^0^ <del>en</del>∈R ^I×D^ 为嵌入的历史序列。</p><p>Encoder( )为：</p><p><img src="/../picture/image-20240414145825496.png" alt="image-20240414145825496"></p><p>其中S^l,i^ <del>en</del>，i∈{ 1，2 }分别表示第l层第i个分解块后的季节分量。对于FEB模块，它有两个不同版本的( FEB-f &amp; FEB-w)，分别通过离散傅里叶变换( DFT )和离散小波变换( DWT )机制实现，可以无缝替代自注意力模块。</p><h4 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h4><p>X^l^ <del>de</del>, T^l^ <del>de</del> &#x3D; Decoder(X^l-1^ <del>de</del>, T^l-1^ <del>de</del> )    其中l∈{ 1，……，M }表示第l个解码层的输出。</p><p>Decoder( )表示为：</p><p> <img src="/../picture/image-20240414150451231.png" alt="image-20240414150451231"></p><p>式中：S^l,i^ <del>de</del>, S^l,i^ <del>de</del>，i∈{ 1，2，3 }分别表示第l层第i个分解块后的季节分量和趋势分量</p><p>W<del>l,i</del>  ， i ∈ {1, 2, 3} 表示第i个被提取的趋势分量 T^l,i^ <del>de</del>  </p><p>与FEB类似，FEA有两个不同的版本( FEA-f &amp; FEA - w)，分别通过DFT和DWT投影实现，并带有注意力设计，可以替代交叉注意力模块。</p><p>最终的预测结果是两个细化分量之和W<del>S</del> · X ^M^ <del>de</del> + T^M^ <del>de</del> </p><p> 其中W<del>S</del> 是为了将将深度变换后的季节分量X^M^ <del>de</del> 投影到目标维度。</p><hr><h2 id="模块结构分解"><a href="#模块结构分解" class="headerlink" title="模块结构分解"></a>模块结构分解</h2><h3 id="离散傅里叶变换（DFT）"><a href="#离散傅里叶变换（DFT）" class="headerlink" title="离散傅里叶变换（DFT）"></a>离散傅里叶变换（DFT）</h3><p>令F表示傅里叶变换 ，F^-1^表示傅里叶逆变换。</p><p>给定一个时间域上的实数序列 x<del>n</del> 。</p><p>离散傅里叶变换公式为：<img src="/../picture/image-20240414153644949.png" alt="image-20240414153644949"> i为虚数单位</p><p>X<del>l</del> ,l &#x3D; 1，2 .. L是频域中的复数序列。</p><p>傅里叶逆变换公式为<img src="/../picture/image-20240414165759776.png" alt="image-20240414165759776"></p><h3 id="Frequency-Enhanced-Block-with-Fourier-Transform-FEB-f"><a href="#Frequency-Enhanced-Block-with-Fourier-Transform-FEB-f" class="headerlink" title="Frequency Enhanced Block with Fourier Transform (FEB-f)"></a>Frequency Enhanced Block with Fourier Transform (FEB-f)</h3><p><img src="/../picture/image-20240422154131401.png" alt="image-20240422154131401"></p><p>1、首先对输入X 运用多层感知机进行线性投影， 求得投影后的q , q &#x3D;  X*w</p><p>2、通过快速傅里叶变换，将时域数据q变为频域数据Q</p><p>3、对频域数据进行随机分量只保留随机选择的M个模态，减少信息冗余、降低增效</p><p><img src="/../picture/image-20240422155305585.png" alt="image-20240422155305585"></p><p>4、随机初始化矩阵R，并与随机选择的频率分量相乘；</p><p>令 $ Y &#x3D; Q⊙C, Y_{m,d_o}&#x3D;\sum_{d_i&#x3D;o}^DQ_{m,d_i}·R_{d_i,d_o,m}$</p><p>$d_i&#x3D; 1,2,3……D，d_o&#x3D;1，2，3，……，D$</p><p>5、为了便于后续进行傅里叶逆变换，需要将数据以0补足维度；<br>6、通过傅里叶逆变换，由频域数据转换为时域数据。</p><p><img src="/../picture/image-20240422160542055.png" alt="image-20240422160542055"></p><h3 id="Frequency-Enhanced-Attention-with-Fourier-Transform-FEA-f"><a href="#Frequency-Enhanced-Attention-with-Fourier-Transform-FEA-f" class="headerlink" title="Frequency Enhanced Attention with Fourier Transform (FEA-f)"></a>Frequency Enhanced Attention with Fourier Transform (FEA-f)</h3><p><img src="/../picture/image-20240422160622053.png" alt="image-20240422160622053"></p><p>1、由Encoder经过多层感知机获得v和k，由Decoder经过多层感知机获得q</p><p>$q &#x3D; x_{en} · w_q$     $k &#x3D; x_{de}·w_k$ $v &#x3D; x_{de}·w_v,$ $w_k, w_v ∈ R^{D×D}.$</p><p>2、 q 、k、v 在快速傅里叶变换下由时域数据转换为频域数据，对他们随机选择分量 </p><p>3、接下来的步骤和传统注意力机制一样：k q相乘后经激活函数再与v相乘；<br>4、为了便于后续进行傅里叶逆变换，需要将数据以0补足维度；<br>5、通过傅里叶逆变换，由频域数据转换为时域数据。</p><h3 id="小波变化的频率增强块（FEB-w）"><a href="#小波变化的频率增强块（FEB-w）" class="headerlink" title="小波变化的频率增强块（FEB-w）"></a>小波变化的频率增强块（FEB-w）</h3><p>由于傅里叶变换存在明显的局限性：</p><p>它只能获取<strong>一段信号总体上包含哪些频率的成分</strong>，但是<strong>对各成分出现的时刻并无所知</strong>。因此时域相差很大的两个信号，可能频谱图一样。</p><p>因此使用小波变换把傅里叶变换的基给换了——将<strong>无限长的三角函数基</strong>换成了<strong>有限长的会衰减的小波基</strong>。这样<strong>不仅能够获取频率</strong>，还可以<strong>定位到时间</strong>了.</p><p>公式如下：</p><p><img src="/../picture/f3342ad8f9f814beecf82b29b0576ef0_720w.webp" alt="img"></p><p>不同于傅里叶变换，变量只有频率ω，小波变换有两个变量：尺度a（scale）和平移量 τ（translation）。<strong>尺度</strong>a控制小波函数的<strong>伸缩</strong>，<strong>平移量</strong> τ控制小波函数的<strong>平移</strong>。<strong>尺度</strong>就对应于<strong>频率</strong>（反比），<strong>平移量</strong> τ就对应于<strong>时间</strong>。<a href="https://www.zhihu.com/question/22864189/answer/40772083">（具体内容参考此文）</a></p><p>文章借鉴：</p><p><a href="https://blog.csdn.net/qq_43166192/article/details/130186788">https://blog.csdn.net/qq_43166192/article/details/130186788</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>文献阅读 时间序列模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口</title>
    <link href="/2024/03/31/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2024/03/31/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>借鉴：<a href="https://www.cnblogs.com/huansky/p/13488234.html">https://www.cnblogs.com/huansky/p/13488234.html</a></p><p>​           <a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/solutions/1362316/by-dodo_1202-cqbe/">https://leetcode.cn/problems/substring-with-concatenation-of-all-words/solutions/1362316/by-dodo_1202-cqbe/</a></p><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>滑动窗口是在给定大小的数组和字符串上进行平滑操作，找到指定内容的方法。由于需要两指针，因此通常需要一些辅助方法，如哈希表（即python中的dict,用于标记元素位置），或集合（即python中的set(),创建一个无序不重复元素集），优先队列，红黑树，单调队列，大小堆等等，应根据各种数据结构的特点来选取。</p><h3 id="思考（也是考点）："><a href="#思考（也是考点）：" class="headerlink" title="思考（也是考点）："></a>思考（也是考点）：</h3><p>1、窗口使用什么数据结构<br>2、达到窗口限定后，左边届该怎样收缩，如果无法以常规方法收缩，考虑延时删除策略（在采集答案前进行）<br>3、怎样采集答案<br>4、滑窗的步长<br>5、滑窗的起始位置<br>6、是否需要数据预处理，例如排序，才能使用滑窗</p><h2 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h2><blockquote><p>1、对字符串 S（或数组） 使用双指针中的左右指针技巧，初始化left &#x3D; right &#x3D; 0。 索引闭区间[ left,right]称为一个窗口。</p><p>2、不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）</p><p>3、停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。</p><p>4、重复第2 步和第三步，直到right到达字符串S的尽头</p></blockquote><p>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。</p><p>下面画图理解一下，needs 和 window 相当于计数器，分别记录 T 中字符出现次数和窗口中的相应字符的出现次数。</p><p>初始状态：</p><img src="../picture/2019101621574345.png" alt="在这里插入图片描述" style="zoom:50%;" /><p>增加 right，直到窗口 [left, right] 包含了 T 中所有字符：</p><img src="../picture/20191016215752186.png" alt="在这里插入图片描述" style="zoom:50%;" /><p>现在开始增加 left，缩小窗口 [left, right]。</p><img src="../picture/20191016215807735.png" alt="在这里插入图片描述" style="zoom:50%;" /><p>直到窗口中的字符串不再符合要求，left 不再继续移动。</p><img src="../picture/20191016215824468.png" alt="在这里插入图片描述" style="zoom:50%;" /><p>之后重复上述过程，先移动 right，再移动 left…… 直到 right 指针到达字符串 S 的末端，算法结束。</p><h3 id="寻找最长"><a href="#寻找最长" class="headerlink" title="寻找最长"></a>寻找最长</h3><p>【如果】窗内满足条件， R 向右扩大窗口,并更新最优结果</p><p>【如果】不满足条件， L向右缩小窗口</p><h3 id="寻找最短"><a href="#寻找最短" class="headerlink" title="寻找最短"></a>寻找最短</h3><p>【如果】窗内满足条件， L 向右缩小窗口,并更新最优结果</p><p>【如果】不满足条件， R向右扩大窗口</p><p>例题：[30. 串联所有单词的子串 - 力扣（LeetCode）](<a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">https://leetcode.cn/problems/substring-with-concatenation-of-all-words/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> collection<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Sliding</span> Window(s,t): <span class="hljs-comment"># t即题目中的words</span><br>    n = <span class="hljs-built_in">len</span>(s)<br>    stride = <span class="hljs-built_in">len</span>(t[<span class="hljs-number">0</span>]) <span class="hljs-comment">#定义步长</span><br>    limit = <span class="hljs-built_in">len</span>(words) * stride<br>    <br><br>    <span class="hljs-comment">#它的其他功能与dict相同，但会为一个不存在的键提供默认值，从而避免KeyError异常。    </span><br>    needs = collections.defaultdict(<span class="hljs-built_in">int</span>)<br>    ans = []<br>    <br>    <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> t:<br>        need[w] += <span class="hljs-number">1</span> <br>    <span class="hljs-keyword">for</span> strat <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,stride):<br>        left = right = strat <span class="hljs-comment">#指向当前步子的第一个下标</span><br>        cnt = <span class="hljs-number">0</span> <span class="hljs-comment">#记录窗口内满足要求得单词数</span><br>        window = collections.defaultdict(<span class="hljs-built_in">int</span>)<br><span class="hljs-keyword">while</span> right &lt; n:<br>            <span class="hljs-comment">#右边界入窗</span><br>            cur_right = s[right:right+stride]<br>            <span class="hljs-keyword">if</span> cur_right <span class="hljs-keyword">in</span> need:<br>                window[cur_right] += <span class="hljs-number">1</span><br>               <span class="hljs-keyword">if</span> window[cur_right] == need[cur_right]:<br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 左边界收缩</span><br>            <span class="hljs-keyword">if</span> right - left + stride &gt; limit:<br>                cur_left = s[left:left+stride]<br>                <span class="hljs-keyword">if</span> cur_right <span class="hljs-keyword">in</span> need:<br>                    <span class="hljs-keyword">if</span> window[cur_left] == need[cur_left]:<br>                        cnt -= <span class="hljs-number">1</span><br>                    window[cur_left] -= <span class="hljs-number">1</span><br>                    left += stride<br>            <span class="hljs-comment">#采集答案</span><br>            <span class="hljs-keyword">if</span> right - left +stride == limit <span class="hljs-keyword">and</span> cnt == <span class="hljs-built_in">len</span>(need):<br>                ans.append(left)<br>            right += stride<br><span class="hljs-keyword">return</span> ans<br>            <br>                           <br></code></pre></td></tr></table></figure><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>本模板左右平移步长为1 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> collection<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Sliding</span> Window(s,t):<br>    left = right = <span class="hljs-number">0</span><br>    valid = <span class="hljs-number">0</span> <span class="hljs-comment"># 窗口内已凑齐的字符种类数量</span><br>    window = collections.defaultdict(<span class="hljs-built_in">int</span>)<br>    needs = collections.defaultdict(<span class="hljs-built_in">int</span>)<br>    <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> t:<br>        needs[w] += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> right &lt; <span class="hljs-built_in">len</span>(s):<br>       <span class="hljs-comment">#右边界入窗，对窗口内数据的一系列更新</span><br>        window[s[right]] += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> window[s[right]] == need [s[right]]:<br>            valid += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 注意，先判断再加</span><br>        <br>        <span class="hljs-comment">#判断左侧是否要收缩</span><br>        <span class="hljs-keyword">while</span> 需要收缩:<br>            <span class="hljs-comment">#左边界移除窗口，进行窗口内数据更新</span><br>            <span class="hljs-keyword">if</span> window[s[left]] == need[s[left]]:<br>                valid -= <span class="hljs-number">1</span><br>                <span class="hljs-comment">#先判断再减</span><br>            window[s[left]] -= <span class="hljs-number">1</span><br>            left += <span class="hljs-number">1</span> <span class="hljs-comment"># 注意左侧进行收缩</span><br>        <br>        采集答案<br>        right += <span class="hljs-number">1</span><br>        <br>        <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希表</title>
    <link href="/2024/03/25/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2024/03/25/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote><p>哈希表（又称散列表）， 是一种线性表的存储结构。哈希表由一个直接寻址表和一个哈希函数组成。哈希函数h(k)将元素关键字K作为自变量，返回元素的存储下标。</p></blockquote><h5 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h5><p>例：假设由一个长度为7 的哈希表，哈希函数h(k)&#x3D;k%7。元素集合{14，22，3，5}的存储方式如下表</p><table><thead><tr><th align="center">value</th><th align="center">14</th><th align="center">22</th><th align="center"></th><th align="center">3</th><th align="center"></th><th align="center">5</th><th align="center"></th></tr></thead><tbody><tr><td align="center">i(k%7)</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td></tr></tbody></table><h5 id="直接寻址表"><a href="#直接寻址表" class="headerlink" title="直接寻址表"></a>直接寻址表</h5><p><img src="/.././picture/2feda0dae07f167fa5fa3f320dddf59.png" alt="2feda0dae07f167fa5fa3f320dddf59"></p><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><blockquote><p>当域U很大时，需要消耗大量内存,不实用</p><p>如果域U很大，但实际出现的key很少，则大量空间被浪费</p><p>无法处理关键字不是数字的情况</p></blockquote><h6 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h6><blockquote><p>构建大小为m的寻址表T</p><p>key为k的元素放在h(k)位置上</p><p>h(k)时一个函数，其将域U映射道表T[0,1,2,……,m-1]</p></blockquote><h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><p>当哈希函数返回的位置已经有值时，就会出现哈希冲突</p><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><blockquote><p>开放寻址法 ： 如果哈希函数返回的位置已经有值，则可以向后探查新的位置来存储这个值</p><p>线性探查   ： 如果位置 i 被占用 ， 则探查 i+1, i+2 ,……..</p><p>二次探查  ： 如果位置 i 被占用 ，则探查i+1^2^ , i-1^2^, i +2^2^  ,i-2^2^</p><p>二度哈希 ： 有n个哈希函数，当使用第1个哈希函数h1法生冲突时，则尝试使用h2,h3</p><p>链表法 ： 哈希表每个位置都链接一个链表，当冲突发生时，冲突的元素将被加到该位置链表的最后。</p></blockquote><table><thead><tr><th align="center">0</th><th align="center">496</th><th align="center">896</th><th align="center"></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">337</td><td align="center">356</td></tr><tr><td align="center">2</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">3</td><td align="center">367</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">4</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">5</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">6</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">7</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">8</td><td align="center">184</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">9</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">10</td><td align="center">26</td><td align="center">126</td><td align="center"></td></tr></tbody></table><h4 id="常用哈希函数"><a href="#常用哈希函数" class="headerlink" title="常用哈希函数"></a>常用哈希函数</h4><blockquote><p>除法哈希表：</p><blockquote><p>h(k) &#x3D; k %m</p></blockquote><p>乘法哈希表：</p><blockquote><p>h(k) &#x3D; floor(m * (A * key%1))</p></blockquote><p>全域哈希表：</p><blockquote><p>Ha,b(k) &#x3D; ((a*key + b ) mod p) mod m      a,b &#x3D;1,2,…..,p-1</p></blockquote></blockquote><h4 id="哈希表代码实现"><a href="#哈希表代码实现" class="headerlink" title="哈希表代码实现"></a>哈希表代码实现</h4><p>哈希表  通过哈希函数来计算数据存储位置的数据结构，通常支持如下操作：</p><blockquote><p>insert(key,value):  插入键值(key,value)</p><p>get(key): 如果存在键为key的键值对则返回其value,否则返回空值</p><p>delete(key): 删除键为key的键值对</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs pyhon">class Linklist:<br>    class Node:<br>        def __init__(self,item=None):<br>            self.item = item<br>            self.next = None<br>    class LinklistIterator: #迭代器类  for循环依赖于迭代器,不写迭代器的话,链表不能for循环<br>        def __init__(self,node):<br>            self.node = node<br>        def __next__(self):<br>            if self.node:<br>                cur_node = self.node<br>                self.node = cur_node.next<br>                return cur_node.item<br>            else:<br>                raise StopIteration<br>        &#x27;&#x27;&#x27;<br>        代器规定必要有这个函数 目的是为了 iterator本身必须是iterable<br>        因此定义__iter__ 函数当对iterator求自身iterator时调用自己<br>    <br>       &#x27;&#x27;&#x27;<br>        def __iter__(self):  #迭<br>            return self<br>    def __init__(self,iterable = None):<br>        self.head = None<br>        self.tail = None<br>        if iterable:<br>            self.extend(iterable)<br>    def append(self,obj):<br>        s = Linklist.Node(obj)<br>        if not self.head:<br>            self.head = s<br>            self.tail = s<br>        else:<br>            self.tail.next = s<br>            self.tail = s<br>    def extend(self,iterable):<br>        for obj in iterable:<br>            self.append(obj)<br>    def find(self,obj):<br>        for n in self:<br>            if n == obj:<br>                return True<br>        else:<br>            return False<br>    def __iter__(self): <br>        return self.LinklistIterator(self.head)<br>    def __repr__(self): #转化为字符串<br>        return &quot;&lt;&lt;&quot;+&quot;,&quot;.join(map(str,self))+&#x27;&gt;&gt;&#x27;<br>    &#x27;&#x27;&#x27;map是python内置函数，会根据提供的函数对指定的序列做映射。<br>    map()函数的格式是：map(function,iterable,...) <br>    参数:<br>    function是一个函数名称，通过该函数对后续参数iterable进行处理<br>    iterable是一个可迭代对象，比如：字符串、列表、字典、元组、集合等<br>    &#x27;&#x27;&#x27;<br><br>#类似于集合的结构<br>class HashTable:<br>    def __init__(self,size=101):#size定义哈希表长度<br>        self.size = size<br>        self.T = [Linklist() for i in range(self.size)]<br>    <br>    def h(self,k):<br>        return k % self.size<br>        <br>    def insert(self,k):<br>        i = self.h(k) #k的位置 <br>        if self.find(k):<br>            print(&#x27;重复插入&#x27;)<br>        else:<br>            self.T[i].append(k)<br>    <br>    def find(self,k):<br>        i = self.h(k)<br>        return self.T[i].find(k)<br>ht = HashTable()<br>ht.insert(0)<br>ht.insert(1)<br>ht.insert(101)<br>a= ht.T[0].head.next.item<br>print(a)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kmb算法</title>
    <link href="/2024/03/25/kmb%E7%AE%97%E6%B3%95/"/>
    <url>/2024/03/25/kmb%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h3><p>kmp算法被用来做字符串的匹配。即 快速在 原字符串 中找到 匹配字符串</p><p>kmp算法的复杂度为O(m+n)</p><p>前缀： 包含首字母但不包含尾字母的所有子串。</p><p>后缀：包含尾字母但不包含首字母的所有子串。</p><p>匹配值为 前缀和后缀最大相同字串的长度</p><p>例：</p><pre><code class="hljs"> A B C C A B</code></pre><table><thead><tr><th align="center">前缀</th><th align="center">后缀</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">B</td></tr><tr><td align="center">AB</td><td align="center">AB</td></tr><tr><td align="center">ABC</td><td align="center">CAB</td></tr><tr><td align="center">ABCC</td><td align="center">CCAB</td></tr><tr><td align="center">ABCCA</td><td align="center">BCCAB</td></tr></tbody></table><p>匹配值为 2 （AB）</p><p>所以逐步获取 该字符串的匹配表为：</p><table><thead><tr><th>A</th><th>匹配值为 0</th></tr></thead><tbody><tr><td>AB</td><td>0</td></tr><tr><td>ABC</td><td>0</td></tr><tr><td>ABCC</td><td>0</td></tr><tr><td>ABCCA</td><td>1</td></tr><tr><td>ABCCAB</td><td>2</td></tr></tbody></table><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>当发现某一个字符不匹配时，利用之前遍历过的字符信息来避免暴力算法中的  “回退” 的步骤.</p><p>KMP 算法通过生成的next 数组，当匹配失败时 看最后匹配成功的字符所对应的next 数值p。</p><p>将字串patt的指针返回到 patt [p] 。(p代表字串中可以跳过的字串个数，也即对应字串中的匹配值)</p><p>例：</p><p>主串  A B A B A B C A A </p><p>子串  [A B A B C]</p><p>NEXT [0 0 1  2 0]</p><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">A</th><th align="center">B</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">A</th><th align="center">A</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">B</td><td align="center">A</td><td align="center">B</td><td align="center">C ×</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">0</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>当匹配到 子串 第一个数值时 发现不匹配。因此根据最后匹配成功的的字符 B 对应的next值 2 将指针指到 第2 个A 所在的位置继续匹配。（因为ABAB 匹配值为2  所以之前匹配成功的 AB 与 字串开头的两个 AB 完全一样，因此可以 跳过最长匹配字符 接着看之后数值是否匹配。）</p><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">A</th><th align="center">B</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">A</th><th align="center">A</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center">A</td><td align="center">B</td><td align="center">A</td><td align="center">B</td><td align="center">C</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">0</td><td align="center"></td><td align="center"></td></tr></tbody></table><p>不再需要回退主串中的指针，只需一次便利便可完成匹配 增加了效率</p><h4 id="Next-数组-和-KMP算法实现"><a href="#Next-数组-和-KMP算法实现" class="headerlink" title="Next 数组 和 KMP算法实现"></a>Next 数组 和 KMP算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_next</span>(<span class="hljs-params">patt</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    计算 Next数组</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-built_in">next</span> = [<span class="hljs-number">0</span>] <span class="hljs-comment"># next 数组(初值元素为0)</span><br>    prefix_len = <span class="hljs-number">0</span> <span class="hljs-comment"># 当前共同前后缀的长度</span><br>    i = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(patt):<br>        <span class="hljs-keyword">if</span> patt[prefix_len] == patt[i]:  <span class="hljs-comment">#如果下个字符相同 即可构成更长度的前后缀</span><br>            prefix_len += <span class="hljs-number">1</span><br>            <span class="hljs-built_in">next</span>.append(prefix_len)<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> prefix_len == <span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">next</span>.append(<span class="hljs-number">0</span>) <span class="hljs-comment">#当查表后，依然不存在相应的 数值，则将对应next设为0</span><br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                prefix_len = <span class="hljs-built_in">next</span>[prefix_len - <span class="hljs-number">1</span>] <br>                <span class="hljs-comment"># 当下一个字符不同时，前一个字符相同则只需查遍上一个字符相匹配的字符的后一个字符是否相同，看看是否有更短的前后缀</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">next</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">kmp_search</span>(<span class="hljs-params">string,patt</span>): <span class="hljs-comment">#时间复杂度为 O（n）</span><br><span class="hljs-built_in">next</span> = build_next(patt)<br>    <br>    i = <span class="hljs-number">0</span> <span class="hljs-comment">#主串中的指针</span><br>    j = <span class="hljs-number">0</span> <span class="hljs-comment">#字串中的指针</span><br>    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(string):<br><span class="hljs-keyword">if</span> string[i] == patt[j]: <span class="hljs-comment">#字符串匹配，指针后移</span><br>            i += <span class="hljs-number">1</span><br>        j += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> j &gt; <span class="hljs-number">0</span>: <span class="hljs-comment">#字负匹配失败，根据 next 跳过字串前面的一些字符</span><br>            j = <span class="hljs-built_in">next</span>[j-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">else</span>: <span class="hljs-comment"># 子串第一个字符匹配失败</span><br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> j == <span class="hljs-built_in">len</span>(patt): <span class="hljs-comment">#匹配成功</span><br>            <span class="hljs-keyword">return</span> i-j<br>        <br></code></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">strStr</span>(<span class="hljs-params">self, haystack, needle</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type haystack: str</span><br><span class="hljs-string">        :type needle: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">build_next</span>(<span class="hljs-params">patt</span>):<br>            <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">            计算 Next数组</span><br><span class="hljs-string">            &#x27;&#x27;&#x27;</span><br>            <span class="hljs-built_in">next</span> = [<span class="hljs-number">0</span>] <span class="hljs-comment"># next 数组(初值元素为0)</span><br>            prefix_len = <span class="hljs-number">0</span> <span class="hljs-comment"># 当前共同前后缀的长度</span><br>            i = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(patt):<br>                <span class="hljs-keyword">if</span> patt[prefix_len] == patt[i]:  <span class="hljs-comment">#如果下个字符相同 即可构成更长度的前后缀</span><br>                    prefix_len += <span class="hljs-number">1</span><br>                    <span class="hljs-built_in">next</span>.append(prefix_len)<br>                    i += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> prefix_len == <span class="hljs-number">0</span>:<br>                        <span class="hljs-built_in">next</span>.append(<span class="hljs-number">0</span>) <span class="hljs-comment">#当查表后，依然不存在相应的 数值，则将对应next设为0</span><br>                        i += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        prefix_len = <span class="hljs-built_in">next</span>[prefix_len - <span class="hljs-number">1</span>] <br>                        <span class="hljs-comment"># 当下一个字符不同时，查遍看看是否有更短的前后缀</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">next</span><br>        <span class="hljs-built_in">next</span> = build_next(needle)<br>    <br>        i = <span class="hljs-number">0</span> <span class="hljs-comment">#主串中的指针</span><br>        j = <span class="hljs-number">0</span> <span class="hljs-comment">#字串中的指针</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(haystack):<br>            <span class="hljs-keyword">if</span> haystack[i] == needle[j]: <span class="hljs-comment">#字符串匹配，指针后移</span><br>                i += <span class="hljs-number">1</span><br>                j += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> j &gt; <span class="hljs-number">0</span>: <span class="hljs-comment">#字负匹配失败，根据 next 跳过字串前面的一些字符</span><br>                j = <span class="hljs-built_in">next</span>[j-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">else</span>: <span class="hljs-comment"># 子串第一个字符匹配失败</span><br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> j == <span class="hljs-built_in">len</span>(needle): <span class="hljs-comment">#匹配成功</span><br>                <span class="hljs-keyword">return</span> i-j<br>        <span class="hljs-keyword">if</span> needle <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> haystack:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Adaptive-Normalization-for-Non-stationary-Time-Series-Forecasting:-A Temporal-Slice-Perspective-文献阅读</title>
    <link href="/2024/03/25/Adaptive-Normalization-for-Non-stationary-Time-Series-Forecasting-A-Temporal-Slice-Perspective-%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    <url>/2024/03/25/Adaptive-Normalization-for-Non-stationary-Time-Series-Forecasting-A-Temporal-Slice-Perspective-%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>数据来源：<a href="https://github.com/zhouhaoyi/ETDataset">https://github.com/zhouhaoyi/ETDataset</a></p><p><a href="https://archive.ics.uci.edu/ml/datasets/ElectricityLoadDiagrams20112014">https://archive.ics.uci.edu/ml/datasets/ElectricityLoadDiagrams20112014</a> </p><p><a href="https://github.com/laiguokun/multivariate-time-series-data">https://github.com/laiguokun/multivariate-time-series-data</a> </p><p><a href="http://pems.dot.ca.gov/">http://pems.dot.ca.gov</a> </p><p><a href="https://www.bgc-jena.mpg.de/wetter/">https://www.bgc-jena.mpg.de/wetter/</a> </p><p><a href="https://gis.cdc.gov/grasp/fluview/fluportaldashboard.html">https://gis.cdc.gov/grasp/fluview/fluportaldashboard.html</a> </p><p><a href="https://github.com/cure-lab/LTSF-Linear">https://github.com/cure-lab/LTSF-Linear</a> </p><p><a href="https://github.com/cure-lab/SCINet">https://github.com/cure-lab/SCINet</a></p><h1 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h1><p>【为克服】 使用不适当的统计量进行归一化  【导致的】 输入序列的每个切片的本能模式被破坏，以及未来统计量的不良估计而导致最终预测结果的预测偏移。</p><p>【提出了】 一个用于非平稳时间序列预测的通用归一化框架- -切片自适应归一化 （Slicing Adaptive Normalization  SAN）</p><hr><p>【导致】 不适当统计量的 【原因】：</p><p>【一方面】  现有的大多数方法忽略了输入序列和 horizon series 之间的分布差异，简单地利用输入序列的统计特性来非正则处理输出结果。</p><p>【此外】先前的研究假设在归一化过程中，同一实例内的所有时间点具有相同的统计特性，全局实例归一化被广泛应用。 </p><p>例：<img src="/.././picture/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240325145939.png" alt="微信截图_20240325145939"></p><center style="color:#C0C0C0;text-decoration:underline">能源消费量及其日均值( MeanByDay )的预测实例说明,还将输入序列的均值和horizon series的均值绘制在图中。.jpg</center><p>尽管在时间上相关，但输入序列的均值与 horizon series 的显著( 075 ~ 1 . 5)不同，表明存在潜在的普遍分布差异。</p><hr><h1 id="方法简述"><a href="#方法简述" class="headerlink" title="方法简述"></a>方法简述</h1><p>【首先】  将输入序列分割成互不重叠的等大小切片</p><p>【然后】  根据其统计特性对切片进行归一化处理，并将其输入到预测模型中。</p><p>【同时】  使用一个统计量预测模块，根据输入的统计量来预测未来切片的分布。</p><p>【最后】  利用估计良好的统计量将非平稳信息还原为预测模型的输出。</p><h2 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h2><p>统计量预测模块独立地模拟统计量的演化趋势，SAN采用了更精确的统计量进行自适应的非正规化。</p><p>【因此】 非平稳预测任务实际上被简化为统计预测和平稳预测。</p><p>【此外】  SAN是一个模型无关的框架，可以应用于任意的预测模型。在一个广泛使用的基准数据集上进行了充分的实验。</p><p>【实验结果表明】SAN优于先进的归一化方法，大幅度地提高了各种主流预测模型的性能。</p><hr><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><blockquote><p>对输入序列的每个切片进行归一化去除非平稳因子，通过非归一化以去除非平稳因子，再通过归一化将其恢复到输出序列</p><blockquote><p>基于间跨度T 将输入序列 x^i^ 分成 M 个 非重叠切片 {x^i^ <del>j</del>}^M^ <del>j&#x3D;1</del></p><p>每个切片的均值和标准差计算如下：</p><p><img src="/.././picture/image-20240326155343938.png" alt="image-20240326155343938"></p><p>其中μ^i^ <del>j</del> ,σ^i^ <del>j</del> ∈ R^V*l^   , x^i^ <del>j,t</del> 是 切片x^i^ <del>j</del>  在t时间步长的值。</p><p>通过原始输出谢列的每个切片的单独统计信息进行归一化，公式如下：</p><p><img src="/.././picture/image-20240326160000454.png" alt="image-20240326160000454"></p><p>ε 是一个小常数</p><p>将每个切片归一化后，再按其原始时间顺序回复所有切片，并让没有非平稳因子的处理序列成为模型的新输入</p></blockquote><p>统计预测模块</p><p><img src="/../picture/image-20240327153423905.png" alt="image-20240327153423905"></p><blockquote><p>SAN为两阶段模型</p><p>第一阶段：它首先将统计量预测模块优化为收敛( lsp )，它根据切片输入均值μ^i^和标准差σ^i^来学习预测未来的统计量。将预测的未来统计量用来训练网络，将得出的输出的<img src="/../picture/97ee0efdff4fc9325a900de94182e0f.png" alt="97ee0efdff4fc9325a900de94182e0f">进行非规范化处理的得到<img src="/../picture/image-20240328160521879.png" alt="image-20240328160521879"></p><p>第二阶段 ：传统的训练预测模型的过程( lfc )，其中统计预测模块被冻结并作为插件功能。</p><blockquote><p>认为输入序列的总体均值ρ^i^为目标序列的均值  的极大似然估计</p><p><img src="/../picture/image-20240327155311544.png" alt="image-20240327155311544"></p><center style="color:#C0C0C0;text-decoration:underline">输入序列的总体均值.jpg</center><p><img src="/../picture/image-20240327155355420.png" alt="image-20240327155355420"></p><center style="color:#C0C0C0;text-decoration:underline">目标序列的总体均值.jpg</center><p>基于上述假设 在该方法中引入残差学习技术，让模块学习未来切片均值( μ^i^)与整体输入均值ρ^i^之间的差值，而不是预测具体的值。这种方法降低了在事先知道未来趋势的情况下对均值建模的难度。此外为消除量纲的影响，设置W1,W2∈ R^V^  作为一维向量表示每个变量的权重。</p><p>统计预测过程可以表述为：</p><p><img src="/../picture/image-20240327161044223.png" alt="image-20240327161044223"></p><p>μ^i^&#x3D; [μ^i^ <del>1</del>, μ^i^ <del>2</del>… μ^i^ <del>M</del>]∈ R^V*M^ 表示输入的M个切片的所有均值。</p><p><img src="/../picture/image-20240327161905032.png" alt="image-20240327161905032">代表未来K个切片的预测均值。同样的记法对标准差起作用。</p><p>预测统计量与真实值之间的均方误差( MSE )作为损失函数( lsp )，通过反向传播来训练网络。</p><p>根据预测模型得出输出<img src="/../picture/97ee0efdff4fc9325a900de94182e0f.png" alt="97ee0efdff4fc9325a900de94182e0f">首先将其拆分为K个不重叠的切片：<img src="/../picture/image-20240328160843262.png" alt="image-20240328160843262"> 进行非规范化处理，公式如下：</p><p><img src="/../picture/image-20240328160712695.png" alt="image-20240328160712695"></p><p>最后按时间顺序恢复所有切片，可以得到整个框架的最终预测<img src="/../picture/image-20240328161013160.png" alt="image-20240328161013160">被用于之后的损耗计算（lfc）和性能评估、</p><p>虽然整体框架明了，但培训过程需要仔细考虑，由于SAN的归一化流程是主干模型的约束，因此整个学习过程实际上是一个双层次优化问题。上层的目标是时间序列预测的性能，而下层的目标是非规范化输出和地面实况之间的分布相似性。从形式上讲，原始的整体培训过程可以描述为：</p><p><img src="/../picture/image-20240328162148820.png" alt="image-20240328162148820"></p><p>（为简洁起见，省略了数据的转换过程，只保留了计算所需的原始输入）</p><p>使用随机梯度下降法得出φ^*^ 最优解</p><p>这将原来的非平稳预测任务解耦为统计预测任务和稳态预测任务。在实践中，统计预测模块首先被训练成收敛，然后在训练预测模型的第二阶段被冻结并被视为插件。</p></blockquote></blockquote></blockquote><hr><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>使用多种数据。</p><img src="../picture/image-20240331180908767.png" alt="image-20240331180908767" style="zoom:80%;" /><p>按照时间顺序将每个数据集分为训练集、验证集和测试集。ETT数据集的分割比为6：2：2，其他数据集的分割比为7：1：2。</p><p>SAN 是一个与模型无关的框架，可应用于任意时间序列预测模型。为了证明该框架的有效性，本文选择了一些基于不同架构的主流模型，并评估了它们在多变量和单变量设置下的性能：基于线性模型的DLinear ，基于Transformer的Autoformer 和FEDformer ，以及基于膨胀卷积的SCINet 。本文呢按照 DLinear9 和 SCINet10 官方代码中提供的实现和设置来实现这些模型。</p><h2 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h2><p>使用ADAM 作为所有实验的默认优化器，并报告均方误差（MSE）和平均绝对误差（MAE）作为评估指标。较低的 MSE&#x2F;MAE 表示性能越好。对于SAN中的统计预测模块，为了简单起见，我们使用了一个简单的两层感知器网络，其隐藏大小与骨干模型的嵌入大小相同。</p><h3 id="切片长度"><a href="#切片长度" class="headerlink" title="切片长度"></a>切片长度</h3><p>切片长度的选择采用了启发式的方法，</p><p>即现实世界的时间序列数据在人为定义或实际时间段（每天、每周等）内表现出类似的变化模式。通过梳理基准数据集的频率，本文建立了一个 {6， 12， 24， 48} 的切片长度范围，以便大多数设置涵盖有意义的时间跨度。例如，本文为 ETTh1、电力和交通等数据集选择了 24 的切片长度，频率为 1 小时。这确保了每个时间片在一天内包含数据，并保证了候选人之间的最佳表现。在这里，我们承认我们方法的一个局限性是当前设计无法处理不可分割的长度，因此我们将切片长度设置为 6，这大约代表每周周期，而不是 Exchange 数据集中的 7。</p><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><p>实验最佳结果用粗体表示</p><img src="../picture/1bb4a4118783bd23801bc4d2c343c68.png" alt="1bb4a4118783bd23801bc4d2c343c68" style="zoom: 67%;" /><center style="color:#C0C0C0;text-decoration:underline">多变量设置下的预测误差。.jpg</center><img src="../picture/5c7aac95684ff88509fdd7d9179ca4f.png" alt="5c7aac95684ff88509fdd7d9179ca4f" style="zoom:67%;" /><center style="color:#C0C0C0;text-decoration:underline">SAN 与现有规范化方法的比较.jpg</center><p>清楚地发现，在基准数据集的大多数情况下，SAN框架可以大大提升这些模型。</p><p>本文将这种改进归因于两个方面。</p><p>【首先】SAN减轻了非平稳因素的影响，正如三个典型的非平稳数据集（Exchange、ILI和ETTh2，由ADF测试结果确定）的性能所证明的那样。</p><p>【其次】 即使在长期预测场景中，预测的难度随着预测时间的延长而显著增加，SAN 也会施加约束。</p><p>将SAN模型与的三种最先进的归一化方法：RevIN 、非平稳变压器 （NST） 和 Dish-TS ，根据相同的实验设置进行比较。将SAN模型归一化的方法和其他归一化方法运用到Autoformer和FEDformer模型上，对每个数据集的所有预测长度上的平均MSE评估以及相对改进。</p><p>【结论】 SAN在现有的归一化方法中实现了最佳性能。比较表明，SAN在从时间切片的角度去除非平稳因素方面可能更有效，而不是考虑整个实例。此外，提出的两阶段训练模式至关重要，因为它使 SAN 的性能大大优于 Dish-TS，而 Dish-TS 忽略了双级优化的性质。然而，SAN的这种特殊能力可能会导致过度平稳化问题[25]，导致天气数据集的性能下降。</p><h2 id="预测结果"><a href="#预测结果" class="headerlink" title="预测结果"></a>预测结果</h2><p>下图显示了使用 FEDformer 作为主干的 ETTm2 数据集上的示例预测，并具有 SAN、RevIN、NST 或 Dish-TS 增强功能。<img src="/../picture/image-20240331192350349.png" alt="image-20240331192350349"></p><p>输入长度为 96，预测长度设置为 336。很明显，SAN 可以生成更现实的预测。</p><p>本文猜测 RevIN 和 NST 的质量差是由它们粗略的非规范化方式引起的。尽管输入序列的平均值可以被视为未来数据的最大似然估计，但与输入相比，非平稳数据集的分布可能会发生重大变化。</p><p>因此，简单地使用输入序列统计量对主干模型的输出进行非规范化处理可能会导致不匹配，就像在 RevIN 和 NST 预测中看到的那样，这两个量表相似。</p><p>至于Dish-TS，该方法虽然试图学习未来分布，但它忽略了双层优化的性质，其纠缠的学习模式限制了统计的估计精度，最终导致性能不佳。</p><p>【相反】SAN从切片的角度对时间序列的动态性质进行建模，并引入了一个独立的统计预测模块，以学习通过两阶段训练模式来预测未来非规范化的分布。通过这种方式，我们根据统计预测自适应地调整预测结果的规模和偏差，捕捉未来数据的趋势。因此，尽管输入的平均值相当低，但 SAN 仍会产生与实际情况一致的更高预测。</p><h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><p><img src="/../picture/a5d2e8d4498d126156053330a554543.png" alt="a5d2e8d4498d126156053330a554543"></p>]]></content>
    
    
    
    <tags>
      
      <tag>文献阅读</tag>
      
      <tag>非平稳时间序列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>比较操作符</title>
    <link href="/2024/03/21/%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6-title/"/>
    <url>/2024/03/21/%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6-title/</url>
    
    <content type="html"><![CDATA[<p>Python包含了一系列的魔法方法，用于实现对象之间直接比较，而不需要采用方法调用。同样也可以重载Python默认的比较方法，改变它们的行为。下面是这些方法的列表：</p><ul><li><code>__cmp__</code>(self, other)<br><code>__cmp__</code> 是所有比较魔法方法中最基础的一个，它实际上定义了所有比较操作符的行为（&lt;,&#x3D;&#x3D;,!&#x3D;,等等），但是它可能不能按照你需要的方式工作（例如，判断一个实例和另一个实例是否相等采用一套标准，而与判断一个实例是否大于另一实例采用另一套）。<code>__cmp__</code> 应该在 self &lt; other 时返回一个负整数，在 self &#x3D;&#x3D; other 时返回0，在 self &gt; other 时返回正整数。最好只定义你所需要的比较形式，而不是一次定义全部。如果你需要实现所有的比较形式，而且它们的判断标准类似，那么 <code>__cmp__</code> 是一个很好的方法，可以减少代码重复，让代码更简洁。</li><li><code>__eq__</code>(self, other)<br>定义等于操作符(&#x3D;&#x3D;)的行为。</li><li><code>__ne__</code>(self, other)<br>定义不等于操作符(!&#x3D;)的行为。</li><li><code>__lt__</code>(self, other)<br>定义小于操作符(&lt;)的行为。</li><li><code>__gt__</code>(self, other)<br>定义大于操作符(&gt;)的行为。</li><li><code>__le__</code>(self, other)<br>定义小于等于操作符(&lt;)的行为。</li><li><code>__ge__</code>(self, other)<br>定义大于等于操作符(&gt;)的行为。</li></ul><p>选自：<a href="https://zhuanlan.zhihu.com/p/134649090">非常全的通俗易懂 Python 魔法方法指南（上） - 知乎 (zhihu.com)</a></p><p>例：<a href="https://leetcode.cn/problems/merge-k-sorted-lists/solutions/2384305/liang-chong-fang-fa-zui-xiao-dui-fen-zhi-zbzx/">23. 合并 K 个升序链表 - 力扣（LeetCode）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ListNode.__lt__ = <span class="hljs-keyword">lambda</span> a, b: a.val &lt; b.val  <span class="hljs-comment"># 让堆可以比较节点大小</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小堆</title>
    <link href="/2024/03/19/%E6%9C%80%E5%B0%8F%E5%A0%86-title/"/>
    <url>/2024/03/19/%E6%9C%80%E5%B0%8F%E5%A0%86-title/</url>
    
    <content type="html"><![CDATA[<h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><p>力扣第23题：合并k个升序链表</p><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">输入：lists = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：链表数组如下：<br>[<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br>  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br>将它们合并到一个有序链表中得到。<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">输入：lists = []<br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">输入：lists = [[]]<br>输出：[]<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">23. 合并 K 个升序链表 - 力扣（LeetCode）</a></p><h2 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h2><p>定义：<br>1、堆是一颗完全二叉树；</p><p>2、堆中的某个结点的值总是大于等于（最大堆）或小于等于（最小堆）其孩子结点的值。</p><p>3、堆中每个结点的子树都是堆树。</p><p><img src="/../picture/70" alt="img"><img src="/../picture/80" alt="img"></p><h2 id="python-heapq库"><a href="#python-heapq库" class="headerlink" title="python heapq库"></a>python heapq库</h2><p>最小堆的编写用到heapq库,堆的使用一般用于排序</p><p><a href="https://docs.python.org/zh-cn/3/library/heapq.html">heapq — 堆队列算法 — Python 3.12.2 文档</a></p><h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><p>res.append(path)相当于append进去path的引用，如果你此时改path，那么res里面的结果也会变，这两是指向同一个对象的。path[:]相当于重新赋值了一个对象</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/03/18/hello-world/"/>
    <url>/2024/03/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
